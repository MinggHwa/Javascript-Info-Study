# [자스인 2주차] 신동혁

[📚 공부 정리 ](#-공부-정리)
[🧐 질문 ](#-질문)

---

# 📚 공부 정리

## 5. 자료구조와 자료형

### 5.4 배열

순서있는 컬렉션 저장용 자료구조

#### 배열선언

```js
let arr = new Array();
let arr = [];
```

#### 배열 명령어 등

`length`를 사용하면 배열에 담긴 요소가 몇 개인지 알수 있다.
배열 요소의 자료형엔 제약이 없다.

```js
arr.push(); // 끝쪽 추가
arr.pop(); // 끝쪽 제거
arr.shift(); // 앞쪽 제거
arr.unshift(); // 앞쪽 추가
```

`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느리다

`for in`은 객체용 `for of`는 배열용
`for in`도 쓸수 있지만 10~100배는 느림 `forEach`쓰자

#### 다차차원 배열

중첩객체 같은거.
배열안에 배열.

```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

alert(matrix[1][1]); // 5, 중심에 있는 요소
```

### 5.5 배열과 메서드

#### 1. 기본 메서드

- `push(...items)`  
  배열의 끝에 하나 이상의 요소를 추가하고, 새로운 배열의 길이를 반환한다.

- `pop()`  
  배열의 마지막 요소를 제거하고 그 요소를 반환한다.

- `shift()`  
  배열의 첫 번째 요소를 제거하고 그 요소를 반환한다.

- `unshift(...items)`  
  배열의 앞쪽에 하나 이상의 요소를 추가하고, 새로운 배열의 길이를 반환한다.

#### 2. 변경 메서드

- `splice(start, deleteCount, ...items)`  
  배열의 지정된 위치에서 요소를 삭제하거나 교체하고, 새로운 요소를 추가할 수 있다.

- `slice(start, end)`  
  배열의 일부분을 추출하여 새로운 배열을 반환한다.

#### 3. 배열 검색 및 필터링

- `indexOf(item, from)`  
  배열에서 특정 요소의 첫 번째 인덱스를 반환하며, 요소가 없으면 -1을 반환한다.

- `includes(item)`  
  배열에 특정 요소가 포함되어 있는지 여부를 검사한다.

- `find(callback)`  
  배열에서 주어진 테스트 함수를 만족하는 첫 번째 요소를 반환하며, 찾지 못하면 `undefined`를 반환한다.

- `filter(callback)`  
  배열에서 주어진 테스트 함수를 만족하는 모든 요소를 포함하는 새로운 배열을 반환한다.

#### 4. 배열의 변형

- `map(callback)`  
  배열의 모든 요소에 대해 주어진 함수를 호출하고, 그 결과를 새로운 배열로 반환한다.

- `reduce(callback, initialValue)`  
  배열의 모든 요소를 누적하여 하나의 결과를 반환한다.

- `reduceRight(callback, initialValue)`  
  `reduce`와 비슷하지만 배열을 오른쪽에서 왼쪽으로 처리한다.

- `forEach(callback)`  
  배열의 각 요소에 대해 주어진 함수를 호출하며, 결과를 반환하지 않는다.

#### 5. 배열의 정렬 및 변형

- `sort(compareFunction)`  
  배열의 요소를 정렬한다. 기본적으로 문자열로 변환하여 정렬된다.

- `reverse()`  
  배열의 요소 순서를 반대로 변경한다.

- `concat(...arrays)`  
  두 개 이상의 배열을 결합하여 새로운 배열을 반환한다.

#### 6. 기타 유용한 메서드

- `join(separator)`  
  배열의 모든 요소를 문자열로 결합한다. 구분자는 기본적으로 쉼표(,)이다.

- `toString()`  
  배열을 문자열로 변환한다. 기본적으로 쉼표로 구분된다.

### 5.6 Iterable 객체

#### 1. 반복 가능한 객체란?

반복 가능한 객체(iterable object)는 `for..of` 문과 같은 반복문에서 순회할 수 있는 객체를 말한다. 반복 가능한 객체는 `Symbol.iterator` 메서드를 가지고 있어야 한다. 이 메서드는 반복 가능한 객체에서 반복기를 반환한다.

#### 2. 반복기의 기본 개념

반복기(iterator)는 객체를 순회할 수 있게 해주는 객체로, `next()` 메서드를 가진다. 이 메서드는 `{ value, done }` 형태의 객체를 반환한다. `value`는 현재 값이고, `done`은 반복이 끝났는지의 여부를 나타낸다.

#### 3. 주요 반복 가능한 객체

- **배열**  
  배열은 기본적으로 반복 가능한 객체이며, `for..of` 문에서 직접 순회할 수 있다.

- **문자열**  
  문자열 또한 반복 가능한 객체로, 각 문자를 순회할 수 있다.

- **맵(Map)과 셋(Set)**  
  맵과 셋은 반복 가능한 객체로, `for..of` 문을 통해 각각의 키-값 쌍과 요소를 순회할 수 있다.

- **유사 배열 객체**  
  유사 배열 객체는 배열처럼 `length` 속성을 가지지만, 배열 메서드를 갖지 않는 객체다. 이 객체를 반복 가능하게 만들려면, `Symbol.iterator` 메서드를 구현해야 한다.

#### 4. 사용자 정의 반복 가능한 객체

사용자 정의 객체를 반복 가능하게 만들려면, `Symbol.iterator` 메서드를 구현해야 한다. 이 메서드는 반복기를 반환하는 함수여야 한다.

#### 5. `Symbol.iterator` 메서드

- **구현 방법**  
  `Symbol.iterator` 메서드는 반복기를 반환하는 함수로 정의한다. 반복기는 `next()` 메서드를 가지고 있어야 하며, 이 메서드는 `{ value, done }` 객체를 반환한다.

### 5.7 맵과 셋

#### 1. Map

- **정의**: `Map` 객체는 키와 값의 쌍을 저장하며, 각 키는 유일해야 한다.
- **키**: `Map`의 키는 객체, 기본형 데이터, 혹은 다른 `Map` 객체 등 어떤 값이든 될 수 있다.
- **메서드**:

  - `map.set(key, value)`  
    지정된 키와 값을 `Map`에 추가하거나, 키가 이미 존재하면 값을 업데이트한다.

  - `map.get(key)`  
    지정된 키에 대한 값을 반환한다.

  - `map.has(key)`  
    지정된 키가 `Map`에 존재하는지 여부를 확인한다.

  - `map.delete(key)`  
    지정된 키와 그에 대한 값을 `Map`에서 삭제한다.

  - `map.clear()`  
    `Map`의 모든 키-값 쌍을 삭제한다.

  - `map.keys()`  
    `Map`의 모든 키를 포함하는 반복 가능한 객체를 반환한다.

  - `map.values()`  
    `Map`의 모든 값을 포함하는 반복 가능한 객체를 반환한다.

  - `map.entries()`  
    `Map`의 모든 키-값 쌍을 포함하는 반복 가능한 객체를 반환한다.

#### 2. Set

- **정의**: `Set` 객체는 고유한 값들의 집합을 저장한다. 중복된 값을 허용하지 않는다.
- **메서드**:

  - `set.add(value)`  
    지정된 값을 `Set`에 추가한다. 값이 이미 존재하면 추가하지 않는다.

  - `set.has(value)`  
    지정된 값이 `Set`에 존재하는지 여부를 확인한다.

  - `set.delete(value)`  
    지정된 값을 `Set`에서 삭제한다.

  - `set.clear()`  
    `Set`의 모든 값을 삭제한다.

  - `set.values()`  
    `Set`의 모든 값을 포함하는 반복 가능한 객체를 반환한다.

  - `set.entries()`  
    `Set`의 모든 값-값 쌍을 포함하는 반복 가능한 객체를 반환한다. 값-값 쌍은 `[value, value]` 형태이다.

#### 3. Map과 Set의 사용 예

- **Map 사용 예**:

  ```js
  let map = new Map();
  map.set("name", "Alice");
  map.set("age", 25);

  console.log(map.get("name")); // 'Alice'
  console.log(map.has("age")); // true
  map.delete("age");
  ```

- **set 사용 예**:

  ```js
  let set = new Set();
  set.add(1);
  set.add(2);
  set.add(2); // 중복된 값은 추가되지 않음

  console.log(set.has(1)); // true
  console.log(set.has(3)); // false
  set.delete(1);
  ```

### 5.8 위크맵과 위크셋

#### 1. WeakMap

- **정의**: `WeakMap` 객체는 키-값 쌍을 저장하지만, 키는 약한 참조를 통해 관리된다. 이로 인해 메모리 누수를 방지할 수 있다.
- **키**: `WeakMap`의 키는 객체만 될 수 있으며, 기본형 데이터는 키로 사용할 수 없다.
- **메서드**:

  - `weakMap.set(key, value)`  
    지정된 객체를 키로 사용하여 값을 설정한다. 키가 이미 존재하면 값을 업데이트한다.

  - `weakMap.get(key)`  
    지정된 객체에 대한 값을 반환한다.

  - `weakMap.has(key)`  
    지정된 객체가 `WeakMap`에 존재하는지 여부를 확인한다.

  - `weakMap.delete(key)`  
    지정된 객체와 그에 대한 값을 `WeakMap`에서 삭제한다.

#### 2. WeakSet

- **정의**: `WeakSet` 객체는 객체만을 저장할 수 있는 집합이며, 객체에 대한 약한 참조를 사용하여 메모리 누수를 방지한다.
- **키**: `WeakSet`의 값은 객체만 될 수 있으며, 기본형 데이터는 저장할 수 없다.
- **메서드**:

  - `weakSet.add(value)`  
    지정된 객체를 `WeakSet`에 추가한다. 값이 이미 존재하면 추가하지 않는다.

  - `weakSet.has(value)`  
    지정된 객체가 `WeakSet`에 존재하는지 여부를 확인한다.

  - `weakSet.delete(value)`  
    지정된 객체를 `WeakSet`에서 삭제한다.

#### 3. WeakMap과 WeakSet의 차이점

- **WeakMap**:

  - 키-값 쌍을 저장하며, 키는 객체만 가능하다.
  - 값을 저장하고, 해당 객체를 통해 값에 접근할 수 있다.

- **WeakSet**:
  - 객체만을 저장할 수 있는 집합이다.
  - 주로 객체의 존재 여부를 추적하는 데 사용된다.

#### 4. 요약

- **WeakMap**: 객체를 키로 사용하여 값을 저장하는 데이터 구조이다. 키는 약한 참조로 관리되며, 메모리 누수를 방지한다.
- **WeakSet**: 객체만을 저장할 수 있는 집합으로, 객체에 대한 약한 참조를 사용하여 메모리 누수를 방지한다. 주로 객체의 존재 여부를 체크하는 데 사용된다.

### 5.9 Object.keys, values, entries

#### 1. `Object.keys()`

- **정의**: 객체의 모든 열거 가능한 문자열 키를 배열로 반환한다.
- **형식**: `Object.keys(obj)`
- **반환 값**: 객체 `obj`의 키를 담고 있는 배열

#### 2. `Object.values()`

- **정의**: 객체의 모든 열거 가능한 값들을 배열로 반환한다.
- **형식**: `Object.values(obj)`
- **반환 값**: 객체 `obj`의 값들을 담고 있는 배열

#### 3. `Object.entries()`

- **정의**: 객체의 모든 열거 가능한 키-값 쌍을 배열의 배열 형태로 반환한다.
- **형식**: `Object.entries(obj)`
- **반환 값**: 객체 `obj`의 키-값 쌍을 담고 있는 배열, 각 쌍은 `[key, value]` 형태의 배열로 구성된다.

#### 4. 요약

- **`Object.keys()`**: 객체의 모든 문자열 키를 배열로 반환한다.
- **`Object.values()`**: 객체의 모든 값을 배열로 반환한다.
- **`Object.entries()`**: 객체의 모든 키-값 쌍을 `[key, value]` 형태로 배열로 반환한다.

### 5.10 구조 분해 할당

#### 1. 배열의 구조 분해 할당

- **정의**: 배열의 요소를 개별 변수에 할당할 수 있다.
- **형식**: `let [a, b] = [1, 2]`
- **배열 구조 분해**: 배열의 각 요소를 변수에 매핑할 수 있다. 빈 요소를 생략하거나 기본값을 지정할 수 있다.

#### 2. 객체의 구조 분해 할당

- **정의**: 객체의 속성을 변수에 할당할 수 있다.
- **형식**: `let {a, b} = {a: 1, b: 2}`
- **객체 구조 분해**: 객체의 속성을 변수에 매핑할 수 있으며, 변수의 이름과 속성의 이름이 같아야 한다. 다른 이름으로 매핑하려면 변수명을 변경할 수 있다.

#### 3. 중첩된 구조 분해 할당

- **정의**: 중첩된 배열이나 객체의 구조를 분해하여 변수에 할당할 수 있다.
- **형식**: `let [[a, b], c] = [[1, 2], 3]` 또는 `let {x: {y}} = {x: {y: 1}}`
- **중첩 구조**: 중첩된 데이터 구조를 풀어내어 각 중첩된 수준의 값을 변수에 할당할 수 있다.

#### 4. 기본값

- **정의**: 구조 분해 할당 시 값이 없는 경우 기본값을 지정할 수 있다.
- **형식**: `let [a = 1] = []` 또는 `let {a = 1} = {}`

#### 5. 나머지 연산자

- **정의**: 나머지 연산자를 사용하여 나머지 요소를 배열로 수집할 수 있다.
- **형식**: `let [a, ...rest] = [1, 2, 3, 4]` 또는 `let {a, ...rest} = {a: 1, b: 2, c: 3}`

#### 6. 요약

- **배열 구조 분해**: 배열의 요소를 변수에 할당할 수 있다.
- **객체 구조 분해**: 객체의 속성을 변수에 할당할 수 있으며, 변수명을 조정할 수 있다.
- **중첩된 구조**: 중첩된 배열이나 객체의 요소를 분해하여 변수에 할당할 수 있다.
- **기본값**: 값이 없을 때 기본값을 지정할 수 있다.
- **나머지 연산자**: 나머지 요소를 배열로 수집할 수 있다.

### 5.11 Date 객체와 날짜

#### 1. Date 객체 생성

- **정의**: `Date` 객체는 날짜와 시간을 다루기 위한 내장 객체이다.
- **형식**:

  - `new Date()`  
    현재 날짜와 시간을 기준으로 `Date` 객체를 생성한다.

  - `new Date(dateString)`  
    날짜와 시간 문자열을 파싱하여 `Date` 객체를 생성한다.

  - `new Date(year, month, day, hour, minute, second, millisecond)`  
    지정된 날짜와 시간으로 `Date` 객체를 생성한다.

#### 2. 날짜와 시간의 구성 요소

- **연도**: `date.getFullYear()`
- **월**: `date.getMonth()`  
  (0부터 시작하는 월, 0은 1월)
- **일**: `date.getDate()`
- **시간**: `date.getHours()`
- **분**: `date.getMinutes()`
- **초**: `date.getSeconds()`
- **밀리초**: `date.getMilliseconds()`

#### 3. 날짜와 시간 조작

- **설정**:

  - `date.setFullYear(year)`  
    연도를 설정한다.
  - `date.setMonth(month)`  
    월을 설정한다.
  - `date.setDate(day)`  
    일을 설정한다.
  - `date.setHours(hour)`  
    시간을 설정한다.
  - `date.setMinutes(minute)`  
    분을 설정한다.
  - `date.setSeconds(second)`  
    초를 설정한다.
  - `date.setMilliseconds(millisecond)`  
    밀리초를 설정한다.

- **차이 계산**:
  - 두 날짜 간의 차이는 밀리초 단위로 계산할 수 있다.  
    예: `let difference = date1 - date2`

#### 4. 날짜 형식 변환

- **ISO 문자열**: `date.toISOString()`  
  날짜를 ISO 8601 형식의 문자열로 반환한다.
- **로컬 문자열**: `date.toLocaleString()`  
  날짜를 로컬 형식의 문자열로 반환한다.

- **문자열**: `date.toString()`  
  날짜를 표준 문자열 형식으로 반환한다.

#### 5. 날짜 유틸리티

- **현재 시간**: `Date.now()`  
  현재 시간을 밀리초 단위로 반환한다.

#### 6. 요약

- **Date 객체 생성**: 현재 또는 특정 날짜와 시간으로 `Date` 객체를 생성할 수 있다.
- **날짜와 시간 구성 요소**: 다양한 메서드를 사용하여 날짜와 시간의 구성 요소를 얻거나 설정할 수 있다.
- **날짜와 시간 조작**: 날짜와 시간의 요소를 수정하거나 두 날짜 간의 차이를 계산할 수 있다.
- **날짜 형식 변환**: 날짜를 다양한 문자열 형식으로 변환할 수 있다.
- **날짜 유틸리티**: 현재 시간을 밀리초 단위로 반환할 수 있다.

### 5.12 JSON과 메서드

#### 1. JSON

- **정의**: JSON (JavaScript Object Notation)은 데이터를 교환할 때 사용하는 경량 데이터 포맷이다. 문자열 형태로 데이터를 표현한다.
- **형식**: `{"key": "value", "key2": "value2"}`

#### 2. JSON.stringify()

- **정의**: JavaScript 객체를 JSON 문자열로 변환한다.
- **형식**: `JSON.stringify(value[, replacer[, space]])`
- **매개변수**:
  - `value`: 변환할 JavaScript 값
  - `replacer`: 선택적, 변환 과정에서 제외할 속성을 정의하거나, 값을 변경할 함수
  - `space`: 선택적, 출력할 JSON 문자열의 들여쓰기 공백을 설정

#### 3. JSON.parse()

- **정의**: JSON 문자열을 JavaScript 객체로 변환한다.
- **형식**: `JSON.parse(text[, reviver])`
- **매개변수**:
  - `text`: JSON 문자열
  - `reviver`: 선택적, 변환 과정에서 값을 변경할 함수

#### 4. JSON의 특징과 주의사항

- **문자열의 유효성**: JSON 문자열은 반드시 쌍따옴표 (`"`)를 사용해야 하며, 단일 따옴표 (`'`)는 사용할 수 없다.
- **타입**: JSON에서 지원하는 데이터 타입은 문자열, 숫자, 불리언, 배열, 객체, null이다. 함수, `undefined`, 심볼 등은 지원하지 않는다.

#### 5. JSON과 함수

- **함수 직렬화**: JSON은 함수와 메서드를 직렬화하지 않는다. 함수는 JSON 문자열로 변환할 수 없으며, 객체의 메서드는 JSON으로 저장할 수 없다.

#### 6. 요약

- **JSON.stringify()**: JavaScript 객체를 JSON 문자열로 변환한다. 선택적으로 `replacer`와 `space`를 사용하여 변환을 제어할 수 있다.
- **JSON.parse()**: JSON 문자열을 JavaScript 객체로 변환한다. 선택적으로 `reviver`를 사용하여 변환된 값을 조정할 수 있다.
- **JSON의 특징**: JSON은 문자열 형태로 데이터를 표현하며, 함수나 `undefined` 등은 지원하지 않는다.

## 6. 함수 심화학습

### 6.1 재귀와 스택

#### 1. 재귀 함수

- **정의**: 함수가 자기 자신을 호출하여 문제를 해결하는 기법이다.
- **형식**: 함수는 종료 조건을 설정하고, 조건에 따라 자기 자신을 호출하여 문제를 해결한다.

```js

  function recursiveFunction(params) {
    if (조건) {
      return; // 종료 조건
    }
    recursiveFunction(다음 상태);
  }
```

- **종료 조건**: 재귀 호출이 무한히 반복되지 않도록 하는 중요한 부분이다. 종료 조건을 설정하여 재귀 호출의 기본 단계를 정의한다.

#### 2. 재귀 함수의 동작

- **호출 스택**: 재귀 함수는 호출될 때마다 스택에 쌓인다. 각 호출은 함수의 상태를 유지하며, 호출이 완료되면 스택에서 제거된다.
- **스택 프레임**: 각 함수 호출은 독립적인 스택 프레임을 생성한다. 각 프레임은 함수의 매개변수, 지역 변수, 실행 상태를 포함한다.

#### 3. 재귀와 스택

- **재귀 깊이**: 함수 호출이 깊어질수록 호출 스택의 크기가 커진다. 깊은 재귀는 스택 오버플로우를 초래할 수 있다.
- **스택 오버플로우**: 호출 스택이 너무 커져서 메모리 한계를 초과할 때 발생한다. 일반적으로 재귀 호출이 지나치게 깊어질 때 발생한다.

#### 4. 재귀와 반복문

- **대체**: 많은 재귀적 문제는 반복문을 사용하여 구현할 수 있다. 반복문을 사용하는 것이 일반적으로 메모리 사용 면에서 더 효율적이다.
- **장점**: 재귀는 코드가 간결하고 이해하기 쉬운 경우가 많으며, 특정 문제를 자연스럽게 표현할 수 있는 방법이다.

#### 5. 재귀 사용 예

- **트리 구조 탐색**: 트리 구조나 그래프와 같은 복잡한 데이터 구조를 탐색할 때 유용하다.
- **문제 분할**: 큰 문제를 여러 개의 작은 문제로 나누어 해결할 때 사용된다.

#### 6. 요약

- **재귀 함수**: 함수가 자기 자신을 호출하여 문제를 해결하는 기법이다. 종료 조건을 설정하여 무한 루프를 방지한다.
- **호출 스택**: 재귀 호출 시 각 호출은 스택에 쌓이고, 함수가 종료되면 스택에서 제거된다.
- **스택 오버플로우**: 호출 스택이 너무 커져서 발생하는 문제로, 깊은 재귀 호출 시 주의가 필요하다.
- **반복문 대체**: 재귀는 반복문으로 대체할 수 있으며, 메모리 사용 측면에서 효율적일 수 있다.

### 6.2 나머지 매개변수와 전개 구문

#### 1. 나머지 매개변수 (`rest`)

- **정의**: 함수의 매개변수 중 나머지 인수를 배열로 수집하는 기능이다.
- **형식**: `function func(...rest) { }`
- **용도**: 함수에 전달된 여러 개의 인수를 배열로 받아 처리할 수 있다.

- **특징**:
  - 나머지 매개변수는 함수의 매개변수 목록에서 가장 마지막에 위치해야 한다.
  - 함수 호출 시 전달된 인수 중 나머지 인수를 배열로 모아준다.

#### 2. 전개 구문 (`spread`)

- **정의**: 배열이나 객체를 개별 요소로 펼치는 기능이다.
- **형식**: `let newArray = [...oldArray]` 또는 `let newObject = {...oldObject}`
- **용도**: 배열이나 객체를 쉽게 복사하거나 병합할 수 있다.

- **특징**:
  - 배열의 전개: 배열을 요소로 펼쳐서 새로운 배열을 생성할 수 있다.
  - 객체의 전개: 객체의 속성을 펼쳐서 새로운 객체를 생성할 수 있다.

#### 3. 전개 구문과 나머지 매개변수의 차이

- **전개 구문**: 배열이나 객체를 개별 요소로 변환하여 다른 배열이나 객체에 포함시킬 때 사용된다.
- **나머지 매개변수**: 함수의 매개변수로 전달된 인수를 배열로 수집할 때 사용된다.

#### 4. 사용 예

- **배열 복사**: `let newArray = [...oldArray]`
- **객체 복사**: `let newObject = {...oldObject}`
- **매개변수 처리**: `function func(a, b, ...rest) { }`

#### 5. 요약

- **나머지 매개변수**: 함수에 전달된 나머지 인수를 배열로 수집하여 사용할 수 있다.
- **전개 구문**: 배열이나 객체를 개별 요소로 펼쳐서 새로운 배열이나 객체를 생성할 수 있다.
- **전개와 나머지의 차이**: 전개 구문은 배열이나 객체의 요소를 펼치는 데 사용되며, 나머지 매개변수는 함수의 인수를 배열로 모으는 데 사용된다.

# 🧐 질문
