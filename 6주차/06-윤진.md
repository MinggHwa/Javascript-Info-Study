# [자스인 2주차] 윤진

[🐠 공부 정리 ](#-공부-정리)
[🧐 질문 ](#-질문)

# 🐠 공부 정리

# 14. 기타

## 참조 타입

복잡한 상황에서 메서드를 호출하면 this 값을 잃어버리는 경우가 생김

```js
let user = {
  name: "John",
  hi() {
    alert(this.name);
  },
  bye() {
    alert("Bye");
  },
};

user.hi(); // John (간단한 호출은 의도한 대로 잘 동작합니다.)

// name에 따라 user.hi나 user.bye가 호출되게 해봅시다.
(user.name == "John" ? user.hi : user.bye)(); // TypeError: Cannot read property 'name' of undefined
```

마지막 줄에서 조건부 연산자를 사용해 `user.hi`나 `user.bye` 중 하나가 호출되도록 했는데 에러 발생

이유는 메서드를 호출할 때 "this"에 undefined가 할당되었기 때문

코드를 자세히 살펴보면 `obj.method()`엔 연산이 두 개 있음

1. 점 '.'은 객체 프로퍼티 `obj.method`에 접근
2. 괄호 ()는 접근한 프로퍼티(메서드)를 실행

그렇다면 첫 번째 연산에서 얻은 this 정보가 어떻게 두 번째 연산으로 전달될까?

두 연산을 각각 별도의 줄에 두었다면 this 정보를 잃는 건 확실함

```js
let user = {
  name: "John",
  hi() {
    alert(this.name);
  },
};

// 메서드 접근과 호출을 별도의 줄에서 실행함
let hi = user.hi;
hi(); // this가 undefined이기 때문에 에러가 발생합니다.
```

1. `hi`라는 변수에 `user.hi` 메서드를 할당
2. 이때 `hi`는 단순히 함수 참조가 되었을 뿐, 원래 객체인 `user`와는 연결이 끊어짐
   - `let hi = user.hi;`라는 코드를 실행하면, `hi`는 단순히 `user.hi` 함수의 참조(주소)를 복사하게 됨. 이 과정에서 함수의 this 바인딩은 함께 복사되지 않기 때문에 원래 객체인 `user`와 연결이 끊어지는 것
3. `hi()`를 호출하면 this는 `user` 객체가 아니라, 일반 함수 호출처럼 전역 객체를 가리키거나 `undefined`이기 때문에 에러 발생

**user.hi()를 의도한 대로 동작시키기 위해 자바스크립트는 속임수를 사용**  
**'.'이 함수가 아닌, 참조 타입(Reference Type) 값을 반환하게 함**

참조 타입은 '명세서 에서만 사용되는 타입(specification type)'이라 개발자가 실제론 사용할 수 없음

참조 타입에 속하는 값은 (base, name, strict)이 조합된 형태

- base : 객체
- name : 프로퍼티의 이름
- strict : 엄격 모드에서 true

`user.hi`로 프로퍼티에 접근하면 함수가 아닌, 참조형(참조 타입) 값을 반환. 엄격 모드에선 아래와 같은 값이 반환

```md
// 참조형 값
(user, "hi", true)
```

참조형 값에 괄호 ()를 붙여 호출하면 객체, 객체의 메서드와 연관된 모든 정보를 받음. 이 정보를 기반으로 this(=user) 결정

이렇게 참조 타입은 내부에서 점 .연산에서 알아낸 정보를 괄호 ()로 전달해주는 ‘중개인’ 역할

점 연산 이외의 연산(할당 연산 등)은 참조 타입을 통째로 버리고 `user.hi` 값(함수)만 받아 전달  
그래서 점 이외의 연산에선 this 정보가 사라짐

## BigInt

BigInt는 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형

정수 리터럴 끝에 n을 붙이거나 함수 BigInt를 호출하면 문자열이나 숫자를 가지고 BigInt 타입의 값을 만들 수 있음

```js
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // 10n과 동일합니다.
```

## 숫자 연산자

일반 숫자와 큰 차이 없이 사용

```js
alert(1n + 2n); // 3
alert(5n / 2n); // 2, 소수부가 없다
```

BigInt형 값과 일반 숫자를 섞어서 사용할 순 없음

```js
alert(1n + 2); // Error: Cannot mix BigInt and other types

// 섞어야 하는 상황이라면 형 변환 해주기
let bigint = 1n;
let number = 2;

// 숫자를 bigint로
alert(bigint + BigInt(number)); // 3

// bigint를 숫자로
alert(Number(bigint) + number); // 3
```

형 변환과 관련된 연산은 항상 조용히 동작하기에 절대 에러를 발생시키지 않음  
그런데 bigint가 너무 커서 숫자형에서 허용하는 자릿수를 넘으면 나머지 비트는 자동으로 잘려 나감

```js
let bigint = 1n;

alert(+bigint); // 에러
```

bigint를 대상으로 하는 연산에선 단항 덧셈 연산자를 지원하지 않음  
bigint를 숫자형으로 바꿀 때는 Number()를 사용해야 함

## 비교 연산자

비교 연산자 `<`, `>`는 bigint와 일반 숫자 모두에 사용할 수 있음

```js
alert(2n > 1n); // true

alert(2n > 1); // true
```

비교하려는 대상이 다른 타입에 속할 때

```js
alert(1 == 1n); // true

alert(1 === 1n); // false
```

## 논리 연산

bigint는 if 안이나 다른 논리 연산자와 함께 사용할 때 일반 숫자와 동일하게 행동

if안에서 0n은 falsy이고 다른 값들은 truthy로 평가

```js
if (0n) {
  // 절대 실행되지 않습니다.
}
```

`||`, `&&` 등의 논리 연산자를 bigint에 적용할 때도 일반 숫자와 유사하게 동작

# 15. 문서

## 브라우저 환경과 다양한 명세서

호스트 : 자바스크립트가 돌아가는 플랫폼. 브라우저, 웹서버 등이 될 수 있음  
호스트 환경 : 각 플랫폼마다 특정되는 기능(객체, 함수)을 제공하는 것

![image](https://github.com/user-attachments/assets/8cb564ee-d905-4784-ae06-58a2a7d5efc9)

최상단엔 window라 불리는 ‘루트’ 객체가 있음. window 객체는 2가지 역할을 함

1. 자바스크립트 코드의 전역 객체

```js
function sayHi() {
  alert("안녕하세요.");
}

// 전역 함수는 전역 객체(window)의 메서드임
window.sayHi();
```

2. '브라우저 창(browser window)'을 대변하고, 이를 제어할 수 있는 메서드를 제공

```js
alert(window.innerHeight); // 창 내부(inner window) 높이
```

## 문서 객체 모델(DOM)

문서 객체 모델(Document Object Model, DOM) : 웹 페이지 내의 모든 컨텐츠를 객체로 나타냄. 이 객체는 수정 가능

document 객체는 페이지의 기본 '진입점' 역할  
document 객체를 이용해 페이지 내 그 무엇이든 변경할 수 있고, 원하는 것을 만들 수도 있음

```js
// 배경을 붉은색으로 변경하기
document.body.style.background = "red";

// 1초 후 원상태로 복구하기
setTimeout(() => (document.body.style.background = ""), 1000);
```

## 브라우저 객체 모델(BOM)

브라우저 객체 모델(Browser Object Model, BOM) : 문서 이외의 모든 것을 제어하기 위해 브라우저(호스트 환경)가 제공하는 추가 객체

예시

- navigator 객체는 브라우저와 운영체제에 대한 정보를 제공. 객체엔 다양한 프로퍼티가 있는데 현재 사용 중인 브라우저 정보를 알려주는 `navigator.userAgent`와 브라우저가 실행 중인 운영체제(Windows, Linux, Mac 등) 정보를 알려주는 `navigator.platform`을 많이 사용
- alert/confirm/prompt 역시 BOM의 일부로서 문서와 직접 연결되어 있지 않지만, 사용자와 브라우저 사이의 커뮤니케이션을 도와주는 순수 브라우저 메서드

## CSS 객체 모델(CSSOM)

CSS 객체 모델(CSS Object Model, CSSOM) : CSS 규칙과 스타일시트를 객체로 나타내고 이 객체를 어떻게 읽고 쓸 수 있을지에 대한 설명을 담은 별도의 명세서

## DOM 트리

HTML을 지탱하는 것은 태그(tag)

문서 객체 모델(DOM)에 따르면, 모든 HTML 태그는 객체

모든 객체는 자바스크립트를 통해 접근할 수 있고, 페이지를 조작할 때 이 객체를 사용  
`document.body`는 `<body>` 태그를 객체로 나타낸 것

```js
// <body>가 3초간 붉은색으로 변경
document.body.style.background = "red"; // 배경을 붉은색으로 변경하기

setTimeout(() => (document.body.style.background = ""), 3000); // 원상태로 복구하기
```

## DOM 예제

```html
<!DOCTYPE html>
<html>
  <head>
    <title>사슴에 관하여</title>
  </head>
  <body>
    사슴에 관한 진실.
  </body>
</html>
```

트리 구조로 표현

![image](https://github.com/user-attachments/assets/b91b3d9a-ea9b-4510-8ff2-58939dcc1d26)

트리에 있는 노드는 모두 객체

태그는 요소 노드(element node) (혹은 그냥 요소)이고, 트리 구조를 구성  
`<html>`은 루트 노드가 되고, `<head>`와 `<body>`는 루트 노드의 자식

요소 내의 문자는 텍스트(text) 노드  
자식 노드를 가질 수 없고, 트리의 끝에서 잎 노드(leaf node)가 됨  
새 줄과 공백은 글자나 숫자처럼 항상 유효한 문자로 취급. 이 두 특수문자는 텍스트 노드가 되고, DOM의 일부가 됨

텍스트 노드 생성엔 두 가지 예외가 있음

1. 역사적인 이유로, `<head>` 이전의 공백과 새 줄은 무시됨
1. HTML 명세서에서 모든 콘텐츠는 body 안쪽에 있어야 한다고 했으므로, `</body>` 뒤에 무언가를 넣더라도 그 콘텐츠는 자동으로 body 안쪽으로 옮겨짐. 따라서 `</body>` 뒤엔 공백이 있을 수 없음

## 자동 교정

기형적인 HTML을 만나면 브라우저는 DOM 생성과정에서 HTML을 자동으로 교정

예를 들어 가장 최상위 태그는 항상 `<html>`이어야 하는데 문서에 `<html>` 태그가 없는 경우, 문서 최상위에 이를 자동으로 넣어줌

닫는 태그가 없어도 자동으로 빠진 부분을 채워 넣어줌

## 기타 노드 타입

```js
<!DOCTYPE HTML>
<html>
<body>
  사슴에 관한 진실.
  <ol>
    <li>사슴은 똑똑합니다.</li>
    <!-- comment -->
    <li>그리고 잔꾀를 잘 부리죠!</li>
  </ol>
</body>
</html>
```

![image](https://github.com/user-attachments/assets/38fcd9ba-428c-48ab-b4d9-9642f1d08b1a)

#comment로 표현되는 주석 노드(comment node)는 두 텍스트 노드 사이에 존재

주석은 화면 출력물에 영향을 주지 않는데, 왜 DOM에는 추가되지?

주석 노드는 HTML에 뭔가 있다면 반드시 DOM 트리에 추가되어야 한다는 규칙 때문에 DOM에 추가된 것

**HTML 안의 모든 것은 (심지어 그것이 주석이더라도) DOM을 구성**

## DOM 탐색하기

DOM에 수행하는 모든 연산은 document 객체에서 시작

![image](https://github.com/user-attachments/assets/9345b63b-f624-4e74-8309-83c4103eca59)

## 트리 상단의 documentElement와 body

\<html> = document.documentElement : DOM 트리 꼭대기에 있는 문서 노드, <html> 태그에 해당

\<body> = document.body : \<body> 요소에 해당하는 DOM 노드로, 자주 쓰이는 노드 중 하나

\<head> = document.head

## childNodes, firstChild, lastChild로 자식 노드 탐색하기

자식 노드(child node, children) : 바로 아래의 자식 요소, 자식 노드는 부모 노드의 바로 아래에서 중첩 관계를 만듦

후손 노드(descendants) : 중첩 관계에 있는 모든 요소

childNodes 컬렉션은 텍스트 노드를 포함한 모든 자식 노드를 담고 있음

```html
<!-- document.body의 자식 노드 출력 -->
<html>
  <body>
    <div>시작</div>

    <ul>
      <li>항목</li>
    </ul>

    <div>끝</div>

    <script>
      for (let i = 0; i < document.body.childNodes.length; i++) {
        alert(document.body.childNodes[i]); // Text, DIV, Text, UL, ... , SCRIPT
      }
    </script>
    ...추가 내용...
  </body>
</html>
```

\<script> 아래 더 많은 내용(…추가 내용…)이 있지만, 스크립트 실행 시점엔 브라우저가 추가 내용은 읽지 못한 상태라서 마지막에 \<script> 출력됨

firstChild와 lastChild 프로퍼티를 이용하면 첫 번째, 마지막 자식 노드에 빠르게 접근할 수 있음

## DOM 컬렉션

childNodes는 배열이 아닌 반복 가능한(iterable, 이터러블) 유사 배열 객체인 컬렉션(collection)

특징

1. for..of를 사용할 수 있음

```js
for (let node of document.body.childNodes) {
  alert(node); // 컬렉션 내의 모든 노드를 보여줍니다.
}
```

2. 배열이 아니기 때문에 배열 메서드를 쓸 수 없음

```js
alert(document.body.childNodes.filter); // undefined (filter 메서드가 없습니다.)
```

컬렉션에 배열 메서드를 사용하고 싶다면 Array.from을 적용

```js
alert(Array.from(document.body.childNodes).filter); // function
```

DOM 컬렉션을 비롯해 모든 탐색용 프로퍼티는 읽기 전용

`elem.childNodes`를 참조하고 있는 도중에 DOM에 새로운 노드가 추가되거나 삭제되면, 변경사항이 컬렉션에도 자동으로 반영

주의 : 컬렉션에 for..in 반복문을 사용하지 않기  
for..in 반복문은 객체의 모든 열거 가능한 프로퍼티를 순회하기 때문에 불필요한 프로퍼티까지도 출력

## 형제와 부모 노드

같은 부모를 가진 노드는 형제(sibling) 노드 라고 부름

```html
<html>
  <head>
    ...
  </head>
  <body>
    ...
  </body>
</html>
```

다음 형제 노드에 대한 정보는 `nextSibling`, 이전 형제 노드에 대한 정보는 `previousSibling` 프로퍼티

## 요소 간 이동

![image](https://github.com/user-attachments/assets/bf54060c-499f-4c2c-8341-9f8f8c9ffc8e)

## document.getElementById 혹은 id를 사용해 요소 검색하기

요소에 id 속성이 있으면 위치에 상관없이 메서드 `document.getElementById(id)`를 이용해 접근 가능

```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // 요소 얻기
  let elem = document.getElementById("elem");

  // 배경색 변경하기
  elem.style.background = "red";
</script>
```

id 속성값을 그대로 딴 전역 변수를 이용해 접근할 수도 있음

```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // 변수 elem은 id가 'elem'인 요소를 참조합니다.
  elem.style.background = "red";

  // id가 elem-content인 요소는 중간에 하이픈(-)이 있기 때문에 변수 이름으로 쓸 수 없습니다.
  // 이럴 땐 대괄호(`[...]`)를 사용해서 window['elem-content']로 접근하면 됩니다.
</script>
```

이렇게 요소 id를 따서 자동으로 선언된 전역변수는 동일한 이름을 가진 변수가 선언되면 무용지물

```html
<div id="elem"></div>

<script>
  let elem = 5; // elem은 더이상 <div id="elem">를 참조하지 않고 5가 됩니다.

  alert(elem); // 5
</script>
```

id에 대응하는 전역변수는 명세서의 내용을 구현해 만들어진 것으로 표준이긴 하지만 하위 호환성을 위해 남겨둔 동작  
이런 방식은 스크립트가 간단할 땐 괜찮지만, 이름이 충돌할 가능성이 있기에 추천하지 않음  
실무에서는 `document.getElementById` 사용하기

id 속성값은 중복되선 안 됨

`anyNode.getElementById`가 아닌 `document.getElementById`  
`getElementById`는 document 객체를 대상으로 해당 id를 가진 요소 노드를 찾아줌. 문서 노드가 아닌 다른 노드엔 호출할 수 없음

## querySelectorAll

`elem.querySelectorAll(css)`은 elem의 자식 요소 중 주어진 CSS 선택자에 대응하는 요소 모두를 반환

마지막 `<li>`요소 모두를 반환

```html
<ul>
  <li>1-1</li>
  <li>1-2</li>
</ul>
<ul>
  <li>2-1</li>
  <li>2-2</li>
</ul>
<script>
  let elements = document.querySelectorAll("ul > li:last-child");

  for (let elem of elements) {
    alert(elem.innerHTML); // "1-2", "2-2"
  }
</script>
```

## querySelector

`elem.querySelector(css)`는 주어진 CSS 선택자에 대응하는 요소 중 첫 번째 요소를 반환

`elem.querySelectorAll(css)[0]`과 동일하지만 `elem.querySelectorAll(css)[0]`은 선택자에 해당하는 모든 요소를 검색해 첫 번째 요소만을 반환하고, `elem.querySelector`는 해당하는 요소를 찾으면 검색을 멈춘다는 차이가 있음. `elem.querySelector`가 더 빠른 이유임

## matches

`elem.matches(css)`는 DOM을 검색하는 일이 아닌 요소 elem이 주어진 CSS 선택자와 일치하는지 여부를 판단  
일치한다면 true, 아니라면 false를 반환  
요소가 담겨있는 배열 등을 순회해 원하는 요소만 걸러내고자 할 때 유용

```html
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // document.body.children가 아니더라도 컬렉션이라면 이 메서드를 적용할 수 있습니다.
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      // <a>태그이고, 그 'href' 속상값이 zip으로 끝나면 true, 아니면 false
      alert("주어진 CSS 선택자와 일치하는 요소: " + elem.href);
    }
  }
</script>
```

## closest

`elem.closest(css)`는 elem 자기 자신을 포함하여 CSS 선택자와 일치하는 가장 가까운 조상 요소를 찾아줌

조상 요소 : 부모 요소, 부모 요소의 부모 요소 등 DOM 트리에서 특정 요소의 상위에 있는 요소들

closest메서드는 해당 요소부터 시작해 DOM 트리를 한 단계씩 거슬러 올라가면서 원하는 요소를 찾고, CSS 선택자와 일치하는 요소를 찾으면 검색을 중단하고 해당 요소를 반환

```html
<h1>목차</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">1장</li>
    <li class="chapter">2장</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector(".chapter"); // LI

  alert(chapter.closest(".book")); // UL
  alert(chapter.closest(".contents")); // DIV

  alert(chapter.closest("h1")); // null(h1은 li의 조상 요소가 아님)
</script>
```

## getElementsBy\*

태그나 클래스 등을 이용해 원하는 노드를 찾아주는 메서드  
(`querySelector`를 이용하는 게 더 편리하고 문법도 짧아서 잘 쓰진 않음)

- `elem.getElementsByTagName(tag)` : 주어진 태그에 해당하는 요소를 찾고, 대응하는 요소를 담은 컬렉션을 반환. 매개변수 tag에 "\*"이 들어가면, '모든 태그’가 검색
- `elem.getElementsByClassName(className)` : class 속성값을 기준으로 요소를 찾고, 대응하는 요소를 담은 컬렉션을 반환
- `document.getElementsByName(name)` : 아주 드물게 쓰이는 메서드로, 문서 전체를 대상으로 검색을 수행. 검색 기준은 name 속성값이고, 이 메서드 역시 검색 결과를 담은 컬렉션을 반환

```js
// 문서 내 모든 div를 얻습니다.
let divs = document.getElementsByTagName("div");
```

**s**를 빠트리지 않도록 조심하기

```js
// 동작하지 않는 코드
document.getElementsByTagName("input").value = 5;
```

요소 하나가 아닌 요소 전체가 담긴 컬렉션을 반환하기 때문에 위 코드는 동작하지 않음  
컬렉션 내 요소에 값을 할당하려면 인덱스를 사용해야 함

## 살아있는 컬렉션

'getElementsBy'로 시작하는 모든 메서드는 살아있는 컬렉션을 반환  
문서에 변경이 있을 때마다 컬렉션이 '자동 갱신’되어 최신 상태를 유지

```html
<div>첫 번째 div</div>

<script>
  let divs = document.getElementsByTagName("div");
  alert(divs.length); // 1
</script>

<div>두 번째 div</div>

<script>
  alert(divs.length); // 2
</script>
```

반면, `querySelectorAll`은 정적인 컬렉션을 반환  
컬렉션이 한 번 확정되면 더는 늘어나지 않음

```html
<div>첫 번째 div</div>

<script>
  let divs = document.querySelectorAll("div");
  alert(divs.length); // 1
</script>

<div>두 번째 div</div>

<script>
  alert(divs.length); // 1
</script>
```

## DOM 노드 클래스

DOM 노드는 종류에 따라 각각 다른 프로퍼티를 지원(\<a>는 링크, \<input>은 입력 관련 등등..)  
그런데 모든 DOM 노드는 공통 조상으로부터 만들어지기 때문에 노드 종류는 다르지만, 모든 DOM 노드는 공통된 프로퍼티와 메서드를 지원

![image](https://github.com/user-attachments/assets/d311c88e-c9ce-404d-93f1-b4bd7dad3e2a)

계층 구조 꼭대기엔 EventTarget이 있는데, Node는 EventTarget을, 다른 DOM 노드들은 Node 클래스를 상속받음

- EventTarget : 루트에 있는 ‘추상(abstract)’ 클래스로, 이 클래스에 대응하는 객체는 실제로 만들어지지 않음. EventTarget이 모든 DOM 노드의 베이스에 있기때문에 DOM 노드에서 '이벤트’를 사용할 수 있음.
- Node : 역시 ‘추상’ 클래스로, DOM 노드의 베이스 역할. getter 역할을 하는 `parentNode`, `nextSibling`, `childNodes` 등의 주요 트리 탐색 기능을 제공. Node 클래스의 객체는 절대 생성되지 않음. 텍스트 노드를 위한 Text 클래스와 요소 노드를 위한 Element 클래스, 주석 노드를 위한 Comment클래스는 Node클래스를 상속받음
  - parentNode : 현재 노드의 부모 노드를 참조
  - nextSibling : 현재 노드의 다음 형제 노드를 참조
  - childNodes : 현재 노드의 모든 자식 노드를 NodeList로 반환
- Element : DOM 요소를 위한 베이스 클래스. `getElementsByTagName`, `querySelector` 같이 요소 전용 탐색을 도와주는 프로퍼티나 메서드가 이를 기반으로 함
- HTMLElement : HTML 요소 노드의 베이스 역할을 하는 클래스
  - HTMLInputElement : \<input> 요소에 대응하는 클래스
  - HTMLBodyElement : \<body> 요소에 대응하는 클래스
  - HTMLAnchorElement : \<a> 요소에 대응하는 클래스
  - 이외에도 각 태그에 해당하는 클래스는 고유한 프로퍼티와 메서드를 지원

이렇게 특정 노드에서 사용할 수 있는 프로퍼티와 메서드는 상속을 기반으로 결정

객체는 constructor 프로퍼티를 가진다는 특징을 이용하면 DOM 노드 클래스 이름을 확인할 수 있음  
(constructor 프로퍼티는 객체가 어떤 생성자 함수로부터 만들어졌는지를 나타냄)

constructor 프로퍼티는 클래스 생성자를 참조하고 이름은 constructor.name에 저장되어있다는 점을 이용

```js
alert(document.body.constructor.name); // HTMLBodyElement
```

toString 사용

```js
alert(document.body); // [object HTMLBodyElement]
```

상속 여부는 instanceof를 사용해 확인

```js
alert(document.body instanceof HTMLBodyElement); // true
alert(document.body instanceof HTMLElement); // true
alert(document.body instanceof Element); // true
alert(document.body instanceof Node); // true
alert(document.body instanceof EventTarget); // true
```

## ‘nodeType’ 프로퍼티

nodeType 프로퍼티 : DOM 노드의 '타입’을 알아내고자 할 때 쓰이는 구식 프로퍼티

각 노드 타입은 상숫값을 가짐

- elem.nodeType == 1 : 요소 노드
- elem.nodeType == 3 : 텍스트 노드
- elem.nodeType == 9 : 문서 객체
- 등등..

```html
<body>
  <script>
    let elem = document.body;

    // 타입을 알아봅시다.
    alert(elem.nodeType); // 1 => 요소 노드

    // 첫 번째 자식 노드
    alert(elem.firstChild.nodeType); // 3 => 텍스트 노드

    // 문서 객체의 타입 확인
    alert(document.nodeType); // 9 => 문서 객체
  </script>
</body>
```

nodeType은 타입 확인 하는 데만 쓸 수 있고 바꾸지는 못함

## nodeName과 tagName으로 태그 이름 확인하기

```js
alert(document.body.nodeName); // BODY
alert(document.body.tagName); // BODY
```

tagName과 nodeName의 차이

- tagName 프로퍼티는 요소 노드에만 존재
- nodeName은 모든 Node에 있음
  - 요소 노드를 대상으로 호출하면 tagName과 같은 역할
  - 텍스트 노드, 주석 노드 등에선 노드 타입을 나타내는 문자열을 반환

```html
<body>
  <!-- 주석 -->

  <script>
    // 주석 노드를 대상으로 두 프로퍼티 비교
    alert(document.body.firstChild.tagName); // undefined (요소가 아님)
    alert(document.body.firstChild.nodeName); // #comment

    // 문서 노드를 대상으로 두 프로퍼티 비교
    alert(document.tagName); // undefined (요소가 아님)
    alert(document.nodeName); // #document
  </script>
</body>
```

## innerHTML로 내용 조작하기

innerHTML 프로퍼티를 사용하면 요소 안의 HTML을 문자열 형태로 받아올 수 있고, 요소 안 HTML을 수정하는 것도 가능

```js
<body>
  <p>p 태그</p>
  <div>div 태그</div>

  <script>
    alert( document.body.innerHTML ); // 내용 읽기 document.body.innerHTML =
    '새로운 BODY!'; // 교체
  </script>
</body>
```

![image](https://github.com/user-attachments/assets/2f7dff81-36af-4219-a703-c20c62a34592)

![image](https://github.com/user-attachments/assets/81220a9c-5eb7-4642-bb2a-962509d8a18f)

문법이 틀린 HTML을 넣으면 브라우저가 자동으로 고쳐줌

```js
<body>

  <script>
    document.body.innerHTML = '<b>test'; // 닫는 태그를 잊음
    alert( document.body.innerHTML ); // <b>test</b> (자동으로 수정됨)
  </script>

</body>
```

innerHTML을 사용해 문서에 \<script> 태그를 삽입하면 해당 태그는 HTML의 일부가 되긴 하지만 실행은 되지 않음

## ‘innerHTML+=’ 사용 시 주의점

elem.innerHTML+="추가 html"을 사용하면 요소에 HTML을 추가할 수 있음

```html
chatDiv.innerHTML += "
<div>안녕하세요<img src="smile.gif" /> !</div>
"; chatDiv.innerHTML += "잘 지내죠?";
```

'innerHTML+='은 추가가 아니라 내용을 덮어쓰기 때문에 주의해서 사용해야 함

```js
elem.innerHTML += "...";
// 위 코드는 아래 코드의 축약 버전입니다.
elem.innerHTML = elem.innerHTML + "...";
```

1. 기존 내용 삭제
2. 기존 내용과 새로운 내용을 합친 새로운 내용을 씀

**기존 내용이 '완전히 삭제’된 후 밑바닥부터 다시 내용이 쓰여지기 때문에 이미지 등의 리소스 전부가 다시 로딩됨**  
이외에도 여러 부작용이 있기 때문에 다른 방법을 사용하는 것이 좋음

## outerHTML로 요소의 전체 HTML 보기

outerHTML 프로퍼티엔 요소 전체 HTML이 담겨 있음  
outerHTML은 innerHTML에 요소 자체를 더한 것

```html
<div id="elem">Hello <b>World</b></div>

<script>
  alert(elem.outerHTML); // <div id="elem">Hello <b>World</b></div>
</script>
```

**innerHTML과 달리 outerHTML을 사용해서 HTML을 쓸땐 요소 자체가 바뀌지 않고 DOM 안의 요소를 교체**

```html
<div>Hello, world!</div>

<script>
  let div = document.querySelector("div");

  // div.outerHTML를 사용해 <p>...</p>로 교체
  div.outerHTML = "<p>새로운 요소</p>"; // (*)

  // 어! div가 그대로네요!
  alert(div.outerHTML); // <div>Hello, world!</div> (**)
</script>
```

(\*)에서 \<p>새로운 요소\</p>로 교체했기 때문에 문서에 바뀐 내용이 출력

![image](https://github.com/user-attachments/assets/81009f14-03d7-4c0a-80fb-ce6c6bdccdfa)

![image](https://github.com/user-attachments/assets/4bc24326-ce59-4e52-a378-77e1f5423848)

하지만 얼럿창에는 div가 바뀌지 않았음

![image](https://github.com/user-attachments/assets/fff5cb33-76f6-41f1-b0d3-7334bdfede76)

이런 결과가 나타난 이유는 outerHTML에 하는 할당 연산이 DOM 요소를 수정하지 않기 때문

`div.outerHTML = '<p>새로운 요소</p>';`는 DOM에서 \<div> 요소를 제거하고 \<p> 요소로 대체

하지만 변수 div는 여전히 교체되기 전의 \<div> 요소를 참조하고 있음. 이 참조는 새로운 요소로 업데이트 되지 않으며 이전 요소를 계속 가리킴

따라서 (\*\*)에서 `div.outerHTML`을 호출하면 자바스크립트는 `<div>Hello, world!</div>` 반환

outerHTML의 이런 동작 방식 때문에 outerHTML을 사용할 땐 실수 할 여지가 많음

## nodeValue/data로 텍스트 노드 내용 조작하기

요소가 아닌 노드(텍스트, 주석 노드 등)의 내용을 읽을 때 쓰임. 두 프로퍼티는 거의 동일하게 동작  
주로 data를 많이 사용하는 편

## textContent로 순수한 텍스트만

textContent를 사용하면 <태그>는 제외하고 오로지 텍스트만 추출할 수 있음

```html
<div id="news">
  <h1>주요 뉴스!</h1>
  <p>화성인이 지구를 침공하였습니다!</p>
</div>

<script>
  // 주요 뉴스! 화성인이 지구를 침공하였습니다!
  alert(news.textContent);
</script>
```

innerHTML : 사용자가 입력한 문자열이 'HTML 형태로' 태그와 함께 저장
textContent : 사용자가 입력한 문자열이 '순수 텍스트 형태로' 저장

```js
<div id="elem1"></div>
<div id="elem2"></div>

<script>
  let name = prompt("이름을 알려주세요.", "<b>이보라</b>");

  elem1.innerHTML = name;
  elem2.textContent = name;
</script>
```

![image](https://github.com/user-attachments/assets/45ed5bd9-f155-4995-9570-142cede1256d)

## hidden 프로퍼티

요소를 보여줄지 말지 지정할 때 사용

```html
<div>아래 두 div를 숨겨봅시다.</div>

<div hidden>HTML의 hidden 속성 사용하기</div>

<div id="elem">자바스크립트의 hidden 프로퍼티 사용하기</div>

<script>
  elem.hidden = true;
</script>
```

![image](https://github.com/user-attachments/assets/93e5560f-6f70-4662-95d8-e580097de7f1)

## 속성과 프로퍼티

브라우저는 웹페이지를 만나면 HTML을 읽어(파싱) DOM 객체를 생성

요소 노드에서 대부분의 표준 HTML 속성(attribute)은 DOM 객체의 프로퍼티(property)가 됨

## DOM 프로퍼티

DOM 프로퍼티의 종류는 엄청나게 많은데 이런 내장 프로퍼티만으로 충분하지 않은 경우 자신만의 프로퍼티를 만들 수 있음

`document.body`에 새로운 프로퍼티를 만들기

```js
document.body.myData = {
  name: "Caesar",
  title: "Imperator",
};

alert(document.body.myData.title); // Imperator
```

메서드 추가하기

```js
document.body.sayTagName = function () {
  alert(this.tagName);
};

document.body.sayTagName(); // BODY (sayTagName의 'this'엔 document.body가 저장됩니다.)
```

Element.prototype 같은 내장 프로토타입을 수정하기

```js
Element.prototype.sayHi = function () {
  alert(`Hello, I'm ${this.tagName}`);
};

document.documentElement.sayHi(); // Hello, I'm HTML
document.body.sayHi(); // Hello, I'm BODY
```

DOM 프로퍼티와 메서드는 일반 자바스크립트 객체처럼 행동하므로 아래와 같은 특징을 보임

- 어떤 값이든 가질 수 있음
- 대소문자 가림

## HTML 속성

브라우저는 HTML을 파싱해 DOM 객체를 만들 때 HTML 표준 속성을 인식하고, 이 표준 속성을 사용해 DOM 프로퍼티를 만듦

```html
<body id="body" type="...">
  <input id="input" type="text" />
  <script>
    alert(input.type); // text
    alert(body.type); // type은 body의 표준 속성이 아니므로 DOM 프로퍼티가 생성되지 않아 undefined가 출력됩니다.
  </script>
</body>
```

"type"은 \<input> 요소(HTMLInputElement)에선 표준이지만, \<body>(HTMLBodyElement)에선 아님

이처럼 표준 속성이 아닌 경우, 이에 매핑하는 DOM 프로퍼티가 생성되지 않음

비표준 속성 접근 방법

- elem.hasAttribute(name) : 속성 존재 여부 확인
- elem.getAttribute(name) : 속성값을 가져옴
- elem.setAttribute(name, value) : 속성값을 변경함
- elem.removeAttribute(name) : 속성값을 지움
- elem.attributes : 모든 속성값 읽기

```html
<body something="non-standard">
  <script>
    alert(document.body.getAttribute("something")); // 비표준 속성에 접근
  </script>
</body>
```

HTML 속성 특징

- 대소문자를 가리지 않음
- 값은 항상 문자열

```html
<body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert(elem.getAttribute("About")); // (1) 'Elephant', 속성 읽기

    elem.setAttribute("Test", 123); // (2) 속성 추가하기

    alert(elem.outerHTML); // (3) 추가된 속성 확인하기

    for (let attr of elem.attributes) {
      // (4) 속성 전체 나열하기
      alert(`${attr.name} = ${attr.value}`);
    }
  </script>
</body>
```

(1)

![image](https://github.com/user-attachments/assets/d1589037-21ec-478c-a2ad-7b48fca2094d)

대소문자 구분 안하는 모습

(3)

![image](https://github.com/user-attachments/assets/d31007a2-19ec-44ed-9b1c-e32576b27629)

숫자 123이 문자열 "123"으로 바뀜

(4)

![image](https://github.com/user-attachments/assets/c2851a91-7eef-4106-b6a8-057f1f4605c8)

![image](https://github.com/user-attachments/assets/6e5b397d-1953-4357-a108-630011c3e56c)

![image](https://github.com/user-attachments/assets/d7711f65-09dd-49a2-87cf-c932918334d0)

attributes가 반환하는 컬렉션은 열거 가능(iterable)

## 프로퍼티-속성 동기화

표준 속성이 변하면 대응하는 프로퍼티는 자동으로 갱신

```html
<input />

<script>
  let input = document.querySelector("input");

  // 속성 추가 => 프로퍼티 갱신
  input.setAttribute("id", "id");
  alert(input.id); // id (갱신)

  // 프로퍼티 변경 => 속성 갱신
  input.id = "newId";
  alert(input.getAttribute("id")); // newId (갱신)
</script>
```

`input.value`처럼 동기화가 속성에서 프로퍼티 방향으로만 일어나는 예외상황도 존재

```html
<input />

<script>
  let input = document.querySelector("input");

  // 속성 추가 => 프로퍼티 갱신
  input.setAttribute("value", "text");
  alert(input.value); // text (갱신)

  // 프로퍼티를 변경해도 속성이 갱신되지 않음
  input.value = "newValue";
  alert(input.getAttribute("value")); // text (갱신 안됨!)
</script>
```

속성 value를 수정하면 프로퍼티도 수정  
하지만 프로퍼티를 수정해도 속성은 수정되지 않음

유저의 어떤 행동 때문에 value가 수정되었는데 수정 전의 ‘원래’ 값으로 복구하고 싶은 경우, 속성에 저장된 값을 가지고 올 수 있어서 유용하게 사용될 수 있음

## DOM 프로퍼티 값의 타입

DOM 프로퍼티 값은 대부분 문자열이지만 아닌 경우도 있음  
예를 들어 체크 박스에 사용되는 input.checked 프로퍼티의 경우 불린 값을 가짐

```html
<input id="input" type="checkbox" checked /> checkbox

<script>
  alert(input.getAttribute("checked")); // 속성 값: 빈 문자열
  alert(input.checked); // 프로퍼티 값: true
</script>
```

## 비표준 속성, dataset

비표준 속성은 사용자가 직접 지정한 데이터를 HTML에서 자바스크립트로 넘기고 싶은 경우나 자바스크립트를 사용해 조작할 HTML 요소를 표시하기 위해 사용할 수 있음

```html
<!-- 이름(name) 정보를 보여주는 div라고 표시 -->
<div show-info="name"></div>
<!-- 나이(age) 정보를 보여주는 div라고 표시 -->
<div show-info="age"></div>

<script>
  // 표시한 요소를 찾고, 그 자리에 원하는 정보를 보여주는 코드
  let user = {
    name: "Pete",
    age: 25,
  };

  for (let div of document.querySelectorAll("[show-info]")) {
    // 원하는 정보를 필드 값에 입력해 줌
    let field = div.getAttribute("show-info");
    div.innerHTML = user[field]; // Pete가 'name'에, 25가 'age'에 삽입됨
  }
</script>
```

비표준 속성은 요소에 스타일을 적용할 때 사용되기도 함

```html
<style>
  /* 스타일이 커스텀 속성 'order-state'에 따라 변합니다. */
  .order[order-state="new"] {
    color: green;
  }

  .order[order-state="pending"] {
    color: blue;
  }

  .order[order-state="canceled"] {
    color: red;
  }
</style>

<div class="order" order-state="new">A new order.</div>

<div class="order" order-state="pending">A pending order.</div>

<div class="order" order-state="canceled">A canceled order.</div>
```

왜 커스텀 속성을 사용하는 게 클래스를 사용하는 것보다 선호될까?

이유는 속성은 클래스보다 다루기 편리하다는 점 때문

```js
// 새 클래스를 추가하거나 지우는 것보다 더 쉽게 상태(state)를 바꿀 수 있습니다
div.setAttribute("order-state", "canceled");
```

```js
// 클래스로 변경하기
element.classList.remove("new", "pending", "canceled");
element.classList.add(state);
```

그렇지만 비표준 속성을 사용해 코드를 작성했는데 나중에 그 속성이 표준으로 등록되게 되면 문제가 발생

이런 상황을 방지하기 위해 `data-*` 속성이 있음

**'data-'로 시작하는 속성 전체는 개발자가 용도에 맞게 사용하도록 별도로 예약됨. dataset 프로퍼티를 사용하면 이 속성에 접근할 수 있음**

요소 elem에 이름이 "data-about"인 속성이 있다면 `elem.dataset.about`을 사용해 그 값을 얻을 수 있음

```html
<body data-about="Elephants">
  <script>
    alert(document.body.dataset.about); // Elephants
  </script>
</body>
```

주문 상태 코드 다시 보기

```js
<style>
  .order[data-order-state="new"] {
    color: green;
  }

  .order[data-order-state="pending"] {
    color: blue;
  }

  .order[data-order-state="canceled"] {
    color: red;
  }
</style>

<div id="order" class="order" data-order-state="new">
  A new order.
</div>

<script>
  // 읽기
  alert(order.dataset.orderState); // new

  // 수정하기
  order.dataset.orderState = "pending"; // (*)
</script>
```

`data-order-state` 같이 여러 단어로 구성된 속성은 카멜 표기법을 사용해 `dataset.orderState`으로 변환

`data-*` 속성은 커스텀 데이터를 안전하고 유효하게 전달하고 속성 읽기, 수정 가능

## 문서 수정하기

HTML 문서를 자바스크립트로 만들어보기

```html
<style>
  .alert {
    padding: 15px;
    border: 1px solid #d6e9c6;
    border-radius: 4px;
    color: #3c763d;
    background-color: #dff0d8;
  }
</style>

<div class="alert">
  <strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.
</div>
```

![image](https://github.com/user-attachments/assets/6a4c2e6a-7dbf-46b5-808f-bb932c58e904)

## 요소 생성하기

DOM 노드를 만들때 사용하는 메서드

- document.createElement(tag) : 태그 이름을 사용해 새로운 요소 노드 생성
- document.createTextNode(text) : 주어진 텍스트를 사용해 새로운 텍스트 노드 생성

### 메세지 생성하기

```js
// 1. <div> 요소 만들기
let div = document.createElement("div");

// 2. 만든 요소의 클래스를 'alert'로 설정
div.className = "alert";

// 3. 내용 채워넣기
div.innerHTML = "<strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.";
```

## 삽입 메서드

div가 페이지에 나타나게 하려면 document 어딘가(document.body로 참조할 수 있는 \<body> 안 같은 곳)에 div를 넣어줘야 함

```html
<style>
  .alert {
    padding: 15px;
    border: 1px solid #d6e9c6;
    border-radius: 4px;
    color: #3c763d;
    background-color: #dff0d8;
  }
</style>

<script>
  let div = document.createElement("div");
  div.className = "alert";
  div.innerHTML = "<strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.";

  document.body.append(div);
</script>
```

요소 삽입 메서드 append를 사용해 직접 새롭게 만든 요소 노드를 페이지에 나타나도록 함

노드 삽입 메서드

- node.append(노드나 문자열) : 노드나 문자열을 node 끝에 삽입
- node.prepend(노드나 문자열) : 노드나 문자열을 node 맨 앞에 삽입
- node.before(노드나 문자열) : 노드나 문자열을 node 이전에 삽입
- node.after(노드나 문자열) : 노드나 문자열을 node 다음에 삽입
- node.replaceWith(노드나 문자열) : node를 새로운 노드나 문자열로 대체

삽입 메서드에 임의의 노드 목록이나 문자열을 넘겨줄 수 있음

```html
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  ol.before("before"); // <ol> 앞에 문자열 'before'를 삽입함
  ol.after("after"); // <ol> 뒤에 문자열 'after를 삽입함

  let liFirst = document.createElement("li");
  liFirst.innerHTML = "prepend";
  ol.prepend(liFirst); // <ol>의 첫 항목으로 liFirst를 삽입함

  let liLast = document.createElement("li");
  liLast.innerHTML = "append";
  ol.append(liLast); // <ol>의 마지막 항목으로 liLast를 삽입함
</script>
```

![image](https://github.com/user-attachments/assets/64d5d980-0f01-4a23-bca5-ff57f6a378be)

![image](https://github.com/user-attachments/assets/967d0d7a-c516-47eb-91d4-79ab9df3abf8)

최종 결과 코드로 표현하기

```html
before
<ol id="ol">
  <li>prepend</li>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>append</li>
</ol>
after
```

복수의 노드와 문자열 넣기

```html
<div id="div"></div>
<script>
  div.before("<p>안녕하세요</p>", document.createElement("hr"));
</script>
```

삽입 메서드에 문자열을 넘겨 텍스트 노드를 만들 땐 인수로 넘긴 문자열이 HTML이 아닌 문자열 그 형태로 삽입(특수문자는 이스케이프 처리됨)

최종 결과 코드

```html
&lt;p&gt;안녕하세요&lt;/p&gt;
<hr />
<div id="div"></div>
```

삽입 메서드를 사용하면 문자열은 `elem.textContent`를 사용한 것처럼 안전한 방법으로 삽입되는 것

따라서 노드 삽입 메서드는 DOM 노드나 문자열을 삽입할 때만 사용할 수 있음

`elem.innerHTML`을 사용한 것처럼 태그가 정상적으로 동작할 수 있게 문자열 형태의 'HTML 그 자체’를 삽입하고 싶다면?

## insertAdjacentHTML/Text/Element

`elem.insertAdjacentHTML(where, html)`를 사용

첫 번째 매개변수는 elem을 기준으로 하는 상대 위치로, 다음 값 중 하나

- 'beforebegin' : elem 바로 앞에 html을 삽입
- 'afterbegin' : elem의 첫 번째 자식 요소 바로 앞에 html을 삽입
- 'beforeend' : elem의 마지막 자식 요소 바로 다음에 html을 삽입
- 'afterend' : elem 바로 다음에 html을 삽입

두 번째 매개변수는 HTML 문자열로, 이 HTML은 이스케이프 처리되지 않고 ‘그대로’ 삽입

```html
<div id="div"></div>
<script>
  div.insertAdjacentHTML("beforebegin", "<p>안녕하세요.</p>");
  div.insertAdjacentHTML("afterend", "<p>안녕히 가세요.</p>");
</script>
```

최종 결과 코드

```html
<p>안녕하세요.</p>
<div id="div"></div>
<p>안녕히 가세요.</p>
```

![image](https://github.com/user-attachments/assets/346c22a9-1592-43b6-98e6-3f62b67b98c9)

elem.insertAdjacentHTML(where, html)은 두 가지 형제 메서드가 있음

- elem.insertAdjacentText(where, text) : insertAdjacentHTML과 문법은 같은데, HTML 대신 text를 ‘문자 그대로’ 삽입
- elem.insertAdjacentElement(where, elem) – 역시 같은 문법이지만, 요소를 삽입

이 메서드들은 구색 맞추기 용도이고 보통은 `insertAdjacentHTML`을 사용

## 노드 삭제하기

`node.remove() `사용하면 노드를 삭제

참고로, 요소 노드를 다른 곳으로 옮길 때 기존에 있던 노드를 지울 필요 없음  
모든 노드 삽입 메서드는 자동으로 기존에 있던 노드를 삭제하고 새로운 곳으로 노드를 옮김

## cloneNode로 노드 복제하기

- `elem.cloneNode(true)`을 호출하면 elem의 ‘깊은’ 복제본이 만들어져 속성 전부와 자손 요소 전부가 복사
- `elem.cloneNode(false)`을 호출하면 후손 노드 복사 없이 elem만 복제

```html
<style>
  .alert {
    padding: 15px;
    border: 1px solid #d6e9c6;
    border-radius: 4px;
    color: #3c763d;
    background-color: #dff0d8;
  }
</style>

<div class="alert" id="div">
  <strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.
</div>

<script>
  let div2 = div.cloneNode(true); // 메시지 창 복제
  div2.querySelector("strong").innerHTML = "안녕히 가세요!"; // 복제한 메시지 창 내용 수정

  div.after(div2); // 복제한 메시지 창을 기존 메시지 창 다음에 보여줌
</script>
```

![image](https://github.com/user-attachments/assets/9c0accaf-6b2f-467a-9350-97a601d10d42)

## DocumentFragment

DocumentFragment는 특별한 DOM 노드 타입으로, 여러 노드로 구성된 그룹을 감싸 다른 곳으로 전달하게 해주는 래퍼(wrapper)처럼 동작

문서에 있는 다른 노드를 DocumentFragment에 추가할 수 있는데, DocumentFragment를 문서 어딘가에 삽입하면 DocumentFragment는 사라지고 DocumentFragment에 추가한 노드만 남음

```html
<ul id="ul"></ul>

<script>
  function getListContent() {
    let fragment = new DocumentFragment();

    for (let i = 1; i <= 3; i++) {
      let li = document.createElement("li");
      li.append(i);
      fragment.append(li);
    }

    return fragment;
  }

  ul.append(getListContent()); // <ul>에 DocumentFragment를 추가
</script>
```

최종 결과 코드

```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

DocumentFragment를 직접 사용할 일은 흔지 않음

## 구식 삽입·삭제 메서드

- parentElem.appendChild(node) : parentElem의 마지막 자식으로 node를 추가함
- parentElem.insertBefore(node, nextSibling) : node를 parentElem안의 nextSibling앞에 추가함
- parentElem.replaceChild(node, oldChild) : parentElem의 자식 노드 중 oldChild를 node로 교체함

## 'document.write’에 대한 첨언

document.write : 웹페이지에 뭔가를 더할 때 쓰는 아주 오래된 메서드

![image](https://github.com/user-attachments/assets/53e0cf6c-a2a9-4f0d-9e37-25795beafcb1)

`document.write(html)`를 호출하면 html이 페이지 ‘그 자리에 즉시’ 추가

```html
<p>페이지 어딘가...</p>
<script>
  document.write("<b>자바스크립트를 사용해 Hello 입력</b>");
</script>
<p>끝</p>
```

document.write는 페이지를 불러오는 도중에만 작동하기 때문에 근래에 작성된 스크립트에선 이 메서드를 찾기 힘듦

페이지가 다 로드되고 나서 document.write를 호출하면 기존에 있던 문서 내용이 사라짐

```html
<p>일 초 후, 이 페이지의 내용은 전부 교체됩니다.</p>
<script>
  // 일초 후 document.write 호출
  // 페이지 로드가 끝난 후이므로 기존 내용이 사라집니다.
  setTimeout(() => document.write("<b>...사라졌습니다.</b>"), 1000);
</script>
```

![image](https://github.com/user-attachments/assets/8d9e9037-f4c2-4731-bbbb-96a9e81194b9)

![image](https://github.com/user-attachments/assets/c2332ae2-b587-4b1f-a896-8be9d6132925)

브라우저는 HTML을 ‘읽는(파싱하는)’ 도중에 `document.write(HTML)`를 만나면 텍스트 형식의 HTML을 마치 원래 페이지에 있었던 것 마냥 해석. 중간에 DOM 조작을 하지 않기 때문에 속도가 아주 빨라짐

## 스타일과 클래스

요소에 스타일을 적용할 수 있는 방법

1. CSS에 클래스를 만들고, 요소에 `<div class="...">`처럼 클래스 추가하기
2. `<div style="...">`처럼 프로퍼티를 style에 바로 써주기

## className과 classList

클래스 속성값 전체를 바꾸고 싶을 때는 className

```html
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
```

개별 클래스를 조작하고 싶을 때는 classList

```html
<body class="main page">
  <script>
    // 클래스 추가
    document.body.classList.add("article");

    alert(document.body.className); // main page article
  </script>
</body>
```

classList에 구현된 메서드

- elem.classList.add/remove("class") : class를 추가하거나 제거
- elem.classList.toggle("class") : class가 존재할 경우 class를 제거하고, 그렇지 않은 경우엔 추가
- elem.classList.contains("class") : class 존재 여부에 따라 true/false를 반환

classList는 이터러블 객체이기 때문에 for..of를 사용해 클래스를 나열할 수 있음

```js
<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main과 page가 출력됨
    }
  </script>
</body>
```

## 요소의 스타일

프로퍼티 `elem.style`은 속성 "style"에 쓰인 값에 대응되는 객체  
elem.style.width="100px"은 style 속성값을 문자열 width:100px로 설정한 것과 같음

여러 단어를 이어서 만든 프로퍼티는 다음와 같이 카멜 표기법을 사용

```
background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
```

```js
document.body.style.backgroundColor = prompt(
  "배경을 무슨 색으로 바꿀까요?",
  "green"
);
```

## style 프로퍼티 재지정하기

style 프로퍼티에 값을 할당했다가 시간이 지나 이를 제거해야 할 때 프로퍼티를 삭제하는 대신 빈 문자열을 할당해주어야 함

```js
// 예시를 실행하면 페이지의 <body>가 깜빡입니다.
document.body.style.display = "none"; // hide

setTimeout(() => (document.body.style.display = ""), 1000); // 1초 후 다시 원래 상태로 돌아옵니다.
```

## getComputedStyle로 계산된 스타일 얻기

style 프로퍼티는 "style" 속성의 값을 읽을 때만 사용할 수 있음  
style 프로퍼티만으론 CSS 종속(CSS cascade)값을 다루지 못함

style 프로퍼티를 사용해도 마진값을 읽을 수 없음

```html
<head>
  <style>
    body {
      color: red;
      margin: 5px;
    }
  </style>
</head>
<body>
  붉은 글씨
  <script>
    alert(document.body.style.color); // 빈 문자열
    alert(document.body.style.marginTop); // 빈 문자열
  </script>
</body>
```

그렇다면 마진을 현재 크기보다 20px 더 크게 하려면 어떻게 해야 할까? 원하는 작업을 하려먼 먼저 현재 크기를 알 수 있어야 함

```js
getComputedStyle(element, [pseudo]); // 값을 읽을 요소, ::before같이 의사 요소(pseudo-element)가 필요한 경우 명시
```

```html
<head>
  <style>
    body {
      color: red;
      margin: 5px;
    }
  </style>
</head>
<body>
  <script>
    let computedStyle = getComputedStyle(document.body);

    // 이제 마진과 색 정보를 얻을 수 있습니다.

    alert(computedStyle.marginTop); // 5px
    alert(computedStyle.color); // rgb(255, 0, 0)
  </script>
</body>
```

getComputedStyle을 사용할 때는 `paddingLeft`, `marginTop`, `borderTopWidth`같이 프로퍼티 이름 전체를 정확히 알고 있어야 함

## 요소 사이즈와 스크롤

### 샘플 요소

```html
<div id="example">...텍스트...</div>
<style>
  #example {
    width: 300px;
    height: 200px;
    border: 25px solid #e8c48f;
    padding: 20px;
    overflow: auto;
  }
</style>
```

![image](https://github.com/user-attachments/assets/0d595e70-35e0-49cf-b06f-895cfaa9c97a)

샘플 예시에서 스크롤바가 없었다면 콘텐츠 영역 너비는 300px이었을 것  
그런데 스크롤바가 16px을 차지하기 때문에 콘텐츠 영역 너비가 284px(300 – 16)이 됨

## 기하 프로퍼티

![image](https://github.com/user-attachments/assets/356bd7c2-d5f2-47f5-85b0-75fb4d348ca1)

기하 프로퍼티의 값은 숫자인데 그 단위는 '픽셀’

## offsetParent와 offsetLeft, offsetTop

offset은 요소가 화면에서 차지하는 영역 전체 크기를 나타내는데, 요소의 너비와 높이에 패딩, 스크롤바, 테두리를 합친 크기이며 마진은 포함되지 않음

offsetParent 프로퍼티는 해당 요소를 렌더링할 때, 좌표 계산에 사용되는 가장 가까운 조상 요소의 참조를 반환

CSS position 프로퍼티가 설정되어있는 조상 요소가 없는 경우

1. CSS position 프로퍼티가 absolute나 relative, fixed, sticky인 가장 가까운 조상 요소
2. \<td>나 \<th>, 혹은 \<table>
3. \<body>

offsetLeft와 offsetTop 프로퍼티는 offsetParent를 기준으로 각각 요소가 오른쪽으로, 아래쪽으로 얼마나 떨어져 있는지를 나타냄

```html
<main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">
      ...
    </div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (주의: 문자열 '180px'이 아닌 숫자 180이 반환됩니다.)
  alert(example.offsetTop); // 180
</script>
```

![image](https://github.com/user-attachments/assets/eaa86244-c118-480e-a7b1-52330a47464c)

다음 같은 경우엔 offsetParent가 null이 될 수 있음

1. 화면에 보이지 않는 요소(CSS display 프로퍼티가 none이거나 문서 내에 있지 않은 요소)
2. \<body>와 \<html>
3. position 프로퍼티가 fixed인 요소

## offsetWidth와 offsetHeight

두 프로퍼티는 각각 요소 '가장 바깥 부분(outer)'이 차지하는 너비와 높이 정보를 제공  
테두리를 포함한 요소 '전체’의 사이즈 정보를 제공

![image](https://github.com/user-attachments/assets/7ea0cd25-6bf4-4182-848a-0851decb649c)

샘플 요소를 대상으로 offsetWidth와 offsetHeight를 계산하면

- offsetWidth = 390 : CSS width 프로퍼티(300px)를 사용해 얻을 수 있는 바깥 너비에 패딩(2 _ 20px)과 테두리(2 _ 25px) 너비를 더한 값
- offsetHeight = 290 : 바깥 높이

기하 프로퍼티는 보이는 요소(displayed element)를 대상으로만 계산  
따라서 요소(혹은 이 요소의 조상 요소 중 어떤 것이든)의 CSS display 프로퍼티가 none이거나 문서 내에 해당 요소가 없으면 모든 기하 프로퍼티 값이 0(offsetParent 프로퍼티의 값은 null)

## clientTop과 clientLeft

clientTop과 clientLeft를 사용하면 테두리 두께를 측정할 수 있음

샘플 예시에서 테두리 두께를 계산하면

- clientLeft = 25 : 왼쪽 테두리 너비
- clientTop = 25 : 위쪽 테두리 높이

그런데 사실 clientTop과 clientLeft 프로퍼티는 테두리 높이, 너비와 정확히 일치하지 않음  
정확히는 테두리 바깥을 기준으로 한 테두리 안 상대 좌표를 나타냄

clientTop과 clientLeft의 차이는 아랍어나 히브리어처럼 오른쪽에서 왼쪽으로 글이 전개되는 언어일 때 드러남  
아랍어가 세팅된 브라우저에선 스크롤바가 오른쪽이 아닌 왼쪽에 나타나게 되는데, 그럼 clientLeft에 스크롤바의 너비가 포함  
clientLeft가 25가 아닌 스크롤바 너비를 포함한 41(25 + 16)

## clientWidth와 clientHeight

clientWidth와 clientHeight 프로퍼티는 테두리 안 영역의 사이즈 정보를 제공  
테두리 안에는 콘텐츠 너비와 패딩이 포함되는데, 스크롤바 너비는 포함되지 않음

![image](https://github.com/user-attachments/assets/8f91304c-64b3-489d-b819-1aea01646671)

가로 스크롤바가 없기 때문에 clientHeight는 테두리 안 영역 전체를 더한 값  
높이 200px에 위, 아래 패딩(2 \* 20px)을 더한 값인 240px이 됨

clientWidth를 계산할 때 주의할 점은 세로 스크롤바가 차지하는 너비 16px 때문에 콘텐츠 너비는 300px이 아닌 284px이 된다는 점  
따라서 clientWidth는 콘텐츠 너비 284px에 왼쪽, 오른쪽 패딩(2 \* 20px)을 더한 값인 324px가 됨

**패딩이 없었다면 clientWidth와 clientHeight는 테두리와 스크롤바 안쪽에 있는 콘텐츠 영역의 너비, 높이와 정확히 일치했을 것**

![image](https://github.com/user-attachments/assets/d6d3fde1-79b4-4973-be48-c7727b7ebf23)

따라서 패딩이 없는 경우엔 clientWidth와 clientHeight를 사용해 콘텐츠 영역 크기를 구할 수 있음

## scrollWidth와 scrollHeight

scrollWidth와 scrollHeight 프로퍼티는 clientWidth와 clientHeight 유사한데, 스크롤바에 의해 감춰진 영역도 포함한다는 점에서 차이가 있음

![image](https://github.com/user-attachments/assets/7ddcbc5d-44cd-4a1b-9aac-86c864099e78)

- scrollWidth = 324 : 수평 스크롤바가 없기 때문에 안쪽 영역 전체를 나타내는 clientWidth와 동일

- scrollWidth = 324 : 스크롤 때문에 가려진 영역을 포함한 콘텐츠 영역 높이 전체

- scrollHeight = 723 : 세로 스크롤바에 가려진 부분을 포함하는 콘텐츠 영역 안쪽 전체의 높이

- scrollWidth = 324 : 콘텐츠 영역 안쪽 전체의 너비. 그림은 가로 스크롤바가 없기 때문에 clientWidth와 동일

scrollWidth와 scrollHeight는 요소 크기를 콘텐츠가 차지하는 만큼 늘리고자 할 때 사용할 수 있음

## scrollLeft와 scrollTop

scrollLeft와 scrollTop은 가로 스크롤이 오른쪽, 세로 스크롤이 아래로 움직임에 따라 가려진 영역의 너비와 높이

![image](https://github.com/user-attachments/assets/eec44f1e-7bf1-4e37-91b5-0542acb6ba1f)

이렇게 scrollTop은 ‘세로 스크롤바에 의해 가려져 보이지 않는’ 위쪽 콘텐츠의 높이

기하 프로퍼티 대부분은 읽기전용이지만 scrollLeft와 scrollTop은 변경이 가능  
예를들어 스크롤바가 10px 아래로 내려가도록 `elem.scrollTop += 10`을 스크립트에 추가할 수 있음

## CSS를 사용해 너비와 높이를 얻지 마세요

왜 getComputedStyle를 사용해 요소 너비와 높이를 얻지 말라고 하는 걸까?

1. CSS width와 height는 다른 CSS 프로퍼티의 영향을 받음. 요소의 너비와 높이 계산 방법을 '지정’하는 box-sizing이 이런 프로퍼티의 대표적인 예. box-sizing을 변경하면 getComputedStyle로 구한 값이 부정확 할 수 있음
2. CSS width와 height는 auto일 수 있음. 인라인 요소(inline element)가 이런 경우에 속함
3. 스크롤바가 콘텐츠 영역을 차지하는 몇몇 브라우저에서 스크롤바가 없으면 정상 동작하는데, 스크롤바가 생기면 의도한 대로 동작하지 않는 코드가 있음. 이들 브라우저에선 콘텐츠가 실제 차지하는 영역이 CSS로 설정한 너비보다 좁은데, clientWidth와 clientHeight는 이를 고려해 클라이언트 요소가 차지하는 공간을 계산.

## 브라우저 창의 너비와 높이

창이 차지하는 너비와 높이를 알려면 document.documentElement의 clientWidth와 clientHeight를 사용하면 됨

![image](https://github.com/user-attachments/assets/fd2fb590-ca41-41b9-a6fa-e87f1e1588ba)

window 객체가 아닌 `document.documentElement`를 쓰는 이유  
스크롤바가 생기면 스크롤바 역시 공간을 차지하는데, `clientWidth`나 `clientHeight`는 스크롤바가 차지하는 공간을 제외해서 너비나 높이 값을 계산  
그런데 `window.innerWidth/innerHeight`는 스크롤바가 차지하는 영역을 포함해 값을 계산

## 문서의 너비와 높이

정확한 문서 전체 높이 값을 얻으려면 아래 여섯 프로퍼티가 반환하는 값 중 최댓값을 골라야 함

```js
let scrollHeight = Math.max(
  document.body.scrollHeight,
  document.documentElement.scrollHeight,
  document.body.offsetHeight,
  document.documentElement.offsetHeight,
  document.body.clientHeight,
  document.documentElement.clientHeight
);

alert("스크롤에 의해 가려진 분을 포함한 전체 문서 높이: " + scrollHeight);
```

## 스크롤 정보 얻기

window객체의 pageXOffset과 pageYOffset을 사용하면 브라우저 상관없이 스크롤 정보를 구할 수 있음

```js
alert("세로 스크롤에 의해 가려진 위쪽 영역 높이: " + window.pageYOffset);
alert("가로 스크롤에 의해 가려진 왼쪽 영역 너비: " + window.pageXOffset);
```

## scrollTo, scrollBy로 스크롤 상태 변경하기

- `scrollBy(x,y)`메서드를 사용하면 페이지의 스크롤 상태를 현재 포지션을 기준으로 상대적으로 조정
- `scrollTo(pageX,pageY)`메서드는 절대 좌표를 기준으로 페이지 스크롤 상태를 변경

이 두 메서드는 브라우저 종류에 상관없이 동일한 동작을 보장

## scrollIntoView

`elem.scrollIntoView(top)`를 호출하면 전체 페이지 스크롤이 움직여 elem이 눈에 보이는 상태로 변경

## 스크롤 막기

document.body.style.overflow = "hidden"를 사용할 수 있습니다. 해당 스크립트가 동작하면 페이지의 스크롤바 위치가 ‘고정’

## 좌표

1. 창 기준 : `position:fixed`와 유사하게 창(window) 맨 위 왼쪽 모서리를 기준으로 좌표를 계산
   - `clientX/clientY`
2. 문서 기준 : 문서(document) 최상단(root)에서 `position:absolute`를 사용하는 것과 비슷하게 문서 맨 위 왼쪽 모서리를 기준으로 좌표를 계산
   - `pageX/pageY`

![image](https://github.com/user-attachments/assets/d574b849-96dc-4708-b603-e7b11e3eec3a)

- pageY : 문서 기준 좌표는 문서 맨 위(오른쪽 그림에선 스크롤 되어 보이지 않음)부터 계산되기 때문에 스크롤 후 값은 전과 동일
- clientY : 문서가 스크롤 되면서 해당 지점이 창 상단과 가까워졌기 때문에 창 기준 좌표가 변함(화살표가 짧아짐)

## getBoundingClientRect로 요소 좌표 얻기

`elem.getBoundingClientRect()` 메서드는 elem을 감싸는 가장 작은 네모의 창 기준 좌표를 DOMRect 클래스의 객체 형태로 반환

DOMRect의 주요 프로퍼티

- x와 y : 요소를 감싸는 네모의 창 기준 X, Y 좌표
- width와 height : 요소를 감싸는 네모의 너비, 높이(음수도 가능)

파생 프로퍼티

- top과 bottom : 요소를 감싸는 네모의 위쪽 모서리, 아래쪽 모서리의 Y 좌표
- left와 right : 요소를 감싸는 네모의 왼쪽 모서리, 오른쪽 모서리의 X 좌표

![image](https://github.com/user-attachments/assets/caee2834-6169-4e91-a95d-c8f064fd77db)

파생 프로퍼티들은 x, y, width, height를 사용해 쉽게 계산 가능

- left = x
- top = y
- right = x + width
- bottom = y + height

`elem.getBoundingClientRect()`를 사용할 때 주의사항

- 좌표는 10.5처럼 소수일 수 있음
- 좌표는 음수일 수 있음

## elementFromPoint(x, y)

`document.elementFromPoint(x, y)`을 호출하면 창 기준 좌표 (x, y)에서 가장 가까운 중첩 요소를 반환

```js
let elem = document.elementFromPoint(x, y);
```

창밖 좌표를 대상으로 elementFromPoint를 호출하면 null이 반환

## 요소를 창 내 특정 좌표에 고정하기

요소 근처에 무언가를 표시할 때에는 getBoundingClientRect를 사용해 요소의 좌표를 얻고 CSS position을 left/top(또는 right/bottom)과 함께 사용해서 표시

## 문서 기준 좌표

문서 기준 좌표는 창이 아닌 문서 왼쪽 위 모서리부터 시작

CSS와 비교하자면 창 기준 좌표는 position:fixed에 해당하고 문서 기준 좌표는 맨 위 기준 position:absolute와 비슷함

요소의 문서 기준 좌표를 제공하는 표준 메서드가 아직 없지만, 두 좌표 체계(창 기준 좌표와 문서 기준 좌표)는 다음 수식을 통해 연관시킬 수 있음

- pageY = clientY + 문서에서 세로 방향 스크롤에 의해 밀려난 부분의 높이
- pageX = clientX + 문서에서 가로 방향 스크롤에 의해 밀려난 부분의 너비

# 16. 이벤트 기초

## 이벤트 핸들러

이벤트에 반응하려면 이벤트가 발생했을 때 실행되는 함수인 핸들러(handler) 를 할당해야 함

### HTML 속성

HTML 안의 on\<event> 속성에 핸들러를 할당할 수 있음

```html
<input value="클릭해 주세요." onclick="alert('클릭!')" type="button" />
```

onclick="alert("클릭!")"과 같이 속성값 내부에 또 큰따옴표를 쓰면 코드가 작동하지 않음

HTML 속성은 대·소문자를 구분하지 않기 때문에, ONCLICK은 onClick이나 onCLICK과 동일하게 작동

### DOM 프로퍼티

DOM 프로퍼티 on\<event>을 사용해도 핸들러를 할당할 수 있음

```html
<input id="elem" type="button" value="클릭해 주세요." />
<script>
  elem.onclick = function () {
    alert("감사합니다.");
  };
</script>
```

핸들러를 HTML 속성을 사용해 할당하면, 브라우저는 속성값을 이용해 새로운 함수를 만듭니다. 그리고 생성된 함수를 DOM 프로퍼티에 할당

두 예시의 유일한 차이점  
첫 번째 예시에서는 HTML 속성을 사용해 button.onclick을 초기화하고 두 번째 예시에서는 스크립트를 사용한다는 것

**onclick 프로퍼티는 단 하나밖에 없기 때문에, 복수의 이벤트 핸들러를 할당할 수 없음**

핸들러를 제거하고 싶다면 elem.onclick = null 같이 null을 할당

## this로 요소에 접근하기

핸들러 내부에 쓰인 this의 값은 핸들러가 할당된 요소

아래 예시의this.innerHTML에서 this는 button이므로 버튼을 클릭하면 버튼 안의 콘텐츠가 얼럿창에 출력

```html
<button onclick="alert(this.innerHTML)">클릭해 주세요.</button>
```

## 자주 하는 실수

이미 존재하는 함수를 직접 핸들러에 할당하는 예시

```js
function sayThanks() {
  alert("감사합니다!");
}

elem.onclick = sayThanks;
```

이때 함수는 sayThanks처럼 할당. sayThanks()를 할당하면 동작하지 않음

```js
// 올바른 방법
button.onclick = sayThanks;

// 틀린 방법(함수 호출의 결괏(result)값이 할당)
button.onclick = sayThanks();
```

그런데, HTML 속성값에는 괄호가 있어야 함

```html
<input type="button" id="button" onclick="sayThanks()" />
```

브라우저는 속성값을 읽고, 속성값을 함수 본문으로 하는 핸들러 함수를 만들기 때문에 이런 차이가 발생

```js
// 브라우저는 onclick 프로퍼티에 새로운 함수를 할당
button.onclick = function () {
  sayThanks(); // 속성값
};
```

**setAttribute로 핸들러를 할당하지 않기**

```js
// <body>를 클릭하면 에러가 발생합니다.
// 속성은 항상 문자열이기 때문에, 함수가 문자열이 되어버리기 때문입니다.
document.body.setAttribute("onclick", function () {
  alert(1);
});
```

**DOM 프로퍼티는 대·소문자를 구분**
핸들러 할당 시 elem.onclick은 괜찮지만, elem.ONCLICK은 안됨

## addEventListener

핸들러를 여러 개 할당

```js
element.addEventListener(event, handler, [options]);
```

event : 이벤트 이름(예: "click")
handler : 핸들러 함수
options : 아래 프로퍼티를 갖는 객체

- once : true이면 이벤트가 트리거 될 때 리스너가 자동으로 삭제
- capture : 어느 단계에서 이벤트를 다뤄야 하는지를 알려주는 프로퍼티
- passive : true이면 리스너에서 지정한 함수가 preventDefault()를 호출하지 않음

핸들러 삭제

```js
element.removeEventListener(event, handler, [options]);
```

삭제는 동일한 함수만 할 수 있음

```js
elem.addEventListener("click", () => alert("감사합니다!"));
// ....
elem.removeEventListener("click", () => alert("감사합니다!"));
```

removeEventListener를 썼지만, 핸들러는 지워지지 않음

함수는 똑같게 생겼지만 다른 함수이기 때문임

```js
function handler() {
  alert("감사합니다!");
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
```

이렇게 사용해야 함. 변수에 핸들러 함수를 저장해 놓지 않으면 핸들러를 지울 수 없음

## 이벤트 객체

이벤트가 발생하면 브라우저는 *이벤트 객체(event object)*라는 것을 만들고, 여기에 이벤트에 관한 상세한 정보를 넣은 다음, 핸들러에 인수 형태로 전달

```html
<input type="button" value="클릭해 주세요." id="elem" />

<script>
  elem.onclick = function (event) {
    // 이벤트 타입과 요소, 클릭 이벤트가 발생한 좌표를 보여줌
    alert(
      event.type + " 이벤트가 " + event.currentTarget + "에서 발생했습니다."
    );
    alert(
      "이벤트가 발생한 곳의 좌표는 " +
        event.clientX +
        ":" +
        event.clientY +
        "입니다."
    );
  };
</script>
```

이벤트 객체에서 지원하는 프로퍼티 중 일부

- `event.type` : 이벤트 타입, 위 예시에선 "click"
- `event.currentTarget` : 이벤트를 처리하는 요소. 화살표 함수를 사용해 핸들러를 만들거나 다른 곳에 바인딩하지 않은 경우엔 this가 가리키는 값과 같음, 화살표 함수를 사용했거나 함수를 다른 곳에 바인딩한 경우엔 `event.currentTarget`를 사용해 이벤트가 처리되는 요소 정보를 얻을 수 있음

HTML에서 핸들러를 할당한 경우에도 아래와 같이 event 객체를 사용할 수 있음

```html
<input type="button" onclick="alert(event.type)" value="이벤트 타입" />
```

## 객체 형태의 핸들러와 handleEvent

addEventListener를 사용하면 함수뿐만 아니라 객체를 이벤트 핸들러로 할당할 수 있음  
이벤트가 발생하면 객체에 구현한 handleEvent 메서드가 호출

```html
<button id="elem">클릭해 주세요.</button>

<script>
  let obj = {
    handleEvent(event) {
      alert(
        event.type + " 이벤트가 " + event.currentTarget + "에서 발생했습니다."
      );
    },
  };

  elem.addEventListener("click", obj);
</script>
```

클래스 사용

```html
<button id="elem">클릭해 주세요.</button>

<script>
  class Menu {
    handleEvent(event) {
      switch (event.type) {
        case "mousedown":
          elem.innerHTML = "마우스 버튼을 눌렀습니다.";
          break;
        case "mouseup":
          elem.innerHTML += " 그리고 버튼을 뗐습니다.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener("mousedown", menu);
  elem.addEventListener("mouseup", menu);
</script>
```

addEventListener를 사용할 때는 요소에 타입을 정확히 명시해 주어야 함

## 버블링과 캡처링

아래 핸들러는 \<div>에 할당되어 있지만, \<em> 이나 \<code>같은 중첩 태그를 클릭해도 동작

```html
<div onclick="alert('div에 할당한 핸들러!')">
  <em
    ><code>EM</code>을 클릭했는데도 <code>DIV</code>에 할당한 핸들러가
    동작합니다.</em
  >
</div>
```

## 버블링

**한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작**  
**가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작**

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">
  FORM
  <div onclick="alert('div')">
    DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

![image](https://github.com/user-attachments/assets/0e867f31-1c1c-4911-a3d0-fc4abecf336d)

가장 안쪽의 \<p>를 클릭하면

1. \<p>에 할당된 onclick 핸들러가 동작
2. 바깥의 \<div>에 할당된 핸들러가 동작
3. 그 바깥의 \<form>에 할당된 핸들러가 동작
4. document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작

![image](https://github.com/user-attachments/assets/326d7bbc-3fa6-4dd6-9d87-de8d3888ff89)

이런 흐름을 '이벤트 버블링’이라고 부름  
이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품(bubble)과 닮았기 때문

## event.target

**이벤트가 발생한 가장 안쪽의 요소는 타깃(target) 요소라고 불리고, event.target을 사용해 접근할 수 있음**

`event.target`과 `this(=event.currentTarget)` 차이점

- `event.target`은 실제 이벤트가 시작된 ‘타깃’ 요소. 버블링이 진행되어도 변하지 않음
- `this`는 ‘현재’ 요소로, 현재 실행 중인 핸들러가 할당된 요소를 참조

`form.onclick` 핸들러 내의 `this`와 `event.target`

- `this(event.currentTarget)` : \<form> 요소에 있는 핸들러가 동작했기 때문에 \<form> 요소를 가리킴
- `event.target` : 폼 안쪽에 실제 클릭한 요소를 가리킴

```js
form.onclick = function (event) {
  // chrome needs some time to paint yellow
  setTimeout(() => {
    alert("target = " + event.target.tagName + ", this=" + this.tagName);
    event.target.style.backgroundColor = "";
  }, 0);
};
```

![image](https://github.com/user-attachments/assets/7471d0fe-2af7-473c-8523-ff45ad31236f)

P를 클릭하면 target = P, this=FORM 메세지 출력  
DIV를 클릭하면 target = DIV, this=FORM 메세지 출력  
FORM을 클릭하면 target = FORM, this=FORM 메세지 출력

## 버블링 중단하기

이벤트 버블링은 타깃 이벤트에서 시작해서 \<html> 요소를 거쳐 document 객체를 만날 때까지 각 노드에서 모두 발생

이벤트 객체의 메서드인 event.stopPropagation()를 사용해 핸들러에게 이벤트를 완전히 처리하고 난 후 버블링을 중단하도록 명령

```html
// 버튼을 클릭해도 `body.onclick`은 동작하지 않음
<body onclick="alert(`버블링은 여기까지 도달하지 못합니다.`)">
  <button onclick="event.stopPropagation()">클릭해 주세요.</button>
</body>
```

한 요소의 특정 이벤트를 처리하는 핸들러가 여러개인 상황에서, 핸들러 중 하나가 버블링을 멈추더라도 나머지 핸들러는 여전히 동작  
event.stopPropagation()은 위쪽으로 일어나는 버블링은 막아주지만, 다른 핸들러들이 동작하는 건 막지 못함

버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 event.stopImmediatePropagation()을 사용  
이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않음

버블링을 꼭 멈춰야 하는 명백한 상황이 아니라면 버블링 막지 않기

## 캡쳐링

표준 DOM 이벤트에서 정의한 이벤트 흐름 3단계

1. 캡처링 단계 : 이벤트가 하위 요소로 전파되는 단계
2. 타깃 단계 : 이벤트가 실제 타깃 요소에 전달되는 단계
3. 버블링 단계 : 이벤트가 상위 요소로 전파되는 단계

![image](https://github.com/user-attachments/assets/9c1c1f4e-9aaa-49ac-89d2-dc3f1719a463)

**캡처링 단계를 이용해야 하는 경우는 흔치 않음**

캡처링 단계에서 이벤트를 잡아내려면 addEventListener의 capture 옵션을 true로 설정

```js
elem.addEventListener(..., {capture: true})
// 아니면, 아래 같이 {capture: true} 대신, true를 써줘도 됩니다.
elem.addEventListener(..., true)
```

capture 옵션은 두 가지 값을 가지는데

- false이면(default 값) 핸들러는 버블링 단계에서 동작
- true이면 핸들러는 캡처링 단계에서 동작

공식적으론 총 3개의 이벤트 흐름이 있지만, 이벤트가 실제 타깃 요소에 전달되는 단계인 ‘타깃 단계’(두 번째 단계)는 별도로 처리되지 않음

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>
  FORM
  <div>
    DIV
    <p>P</p>
  </div>
</form>

<script>
  for (let elem of document.querySelectorAll("*")) {
    elem.addEventListener(
      "click",
      (e) => alert(`캡쳐링: ${elem.tagName}`),
      true
    );
    elem.addEventListener("click", (e) => alert(`버블링: ${elem.tagName}`));
  }
</script>
```

![image](https://github.com/user-attachments/assets/31a6f5a8-0528-4bf0-b249-ad05dbb691b0)

\<p>를 클릭하면 다음과 같은 순서로 이벤트가 전달

1. HTML → BODY → FORM → DIV (캡처링 단계, 첫 번째 리스너)
2. P (타깃 단계, 캡쳐링과 버블링 둘 다에 리스너를 설정했기 때문에 두 번 호출)
3. DIV → FORM → BODY → HTML (버블링 단계, 두 번째 리스너)

`event.eventPhase` 프로퍼티를 이용하면 현재 발생 중인 이벤트 흐름의 단계를 알 수 있음

`addEventListener(..., true)`로 핸들러를 할당해 줬다면, 핸들러를 지울 때, `removeEventListener(..., true)`를 사용해 지워야 함. 같은 단계에 있어야 핸들러가 지워짐

같은 요소와 같은 단계에 설정한 리스너는 설정한 순서대로 동작

# 🧐 질문
